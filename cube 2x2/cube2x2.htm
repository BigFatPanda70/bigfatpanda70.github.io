<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!--
	Title	:	3D 2x2 Cube simulator.
	
	Info	:	Version 1.2	26th December 2022

	Author	:	Nick Fleming.
	
	Updated	:	17th January 2023

	 Notes:
	--------

	These things are hard to find & buy where I live... so I thought
	I'd write a simulator instead !!!

	Going to do it in 3D, but use the html canvas only (not webgl)
	to make it as portable as possible.

	Each individual cube has 3 black faces and 3 coloured faces.
	Doing it this way so when drawing, the inside of the cube will
	always be black.

	+---------+		The coloured sides are drawn with a black outine.
	|\   b   /|		(all generated at run time, if possible)
	| +-----+ |
	|b|  C  |b|
	| +-----+ |
	|/   b   \|
	+---------+

	 26th December 2022
	--------------------
		Decide on basic way to generate the data.
		

	 27th December 2022
	---------------------
		Writing 3D data generation routines.

		Trying to unscramble some of my earlier webgl work to create 
	a simple framework to do stuff with.
	
	One immediate problem is that a canvas cannot have both a webgl
	and a 2d context. Note that a webgl canvas could be 4 times bigger
	than a 2d one.. so perhaps I should have a toggle to force 2D
	if full 3D isn't required ??

		.. so .. for development purposes.. im going to layer a
	2d canvas screen over the top of a rendering screen.

	 28th December 2022
	----------------------
		Getting the webgl code up to scratch is taking a little longer
	as I am trying, as much as possible, to match the canvas code with
	the webgl code for systems where gl is either not available or
	takes up too many system resources.

		Having a complete mental block regarding surface normals !!

	 31st December 2022
	----------------------
		Slowly creeping towards having a software 2D pipeline.


	 1st January 2023
	------------------
		got 8x8 cubes displayed (hurrah !!) just need to decide how
	to handle the rotations around the axis for them all.

	 2nd January 2023
	------------------
		Going to get all the centers of the cubes to align on a whole
	number when not rotating. This is so I can remove any positional 
	errors after rotating. 
	
		Working on clicking on a cube in 3D.. need to refresh my 
	knowledge of ray casting !

	 4th January 2023
	------------------
		Working on getting 3D picking working.. it's fiddly and its 
	not working as I expected it to ! 
	
	 11th January 2023
	---------------------
		Doing pick ray rests.. it appears to be working now.. there 
	were a few problems with multiply order and at least one typo
	where a y coord was used instead of z (grrr.. ! .. but working now!)

	 15th January 2023
	--------------------
		Sunday morning.. doing tests to see how to determine which 
	side and axis to rotate on.

		.. almost working.. except.. rotations are cumulative, so that
	if I rotate about one axis, then another, everything gets out of
	sync and cubes rotate around the wrong axis. oops... 

	 16th January 2023
	-------------------
		Decided it is easier to update the original vertex array after
	each rotation than to try and keep track of the order of rotations
	for each cube, which may become difficult to manage over time.

		Changing code to load 8 copies of the cube data to the object
	buffer code.. so each cube vertices can be rotated and moved
	independently.

		Initial tests.. ok.. appears to freeze in some case but can't
	pin down why.. but it works.
	
	Added funky background and increased rotation speed.
	
	 17th Jan 2023
	----------------
		Got a bug somewhere that sets the animation mode to rotate
	but all the IncAngle variables are zero, so the mode never exits.
	Added a workaround for now that hopefully fixes the issue.
-->

<html>
<head>
<title> 2x2 3D cube V1.2</title>

<style>
	
.overlay
{
	position:absolute;
	left:0;
	top:0;
	width:512;
	height:512;
	background-color:red;
	z-index:10;
	font-family:monospace;
}
	
.container
{
	overscroll-behavior: contain;	/* stops page refresh when vertically scrolling on mobile */

	position:absolute;
	left:0;
	top:0;
	margin:0;
	padding:0;
	width:100vw;
	height:100vh;
	overflow:hidden;
	text-align:center;


	background-image: linear-gradient(to bottom right, #080, #888, #008, #880, #800, #840);	

		/* flex box version */
/*	display:flex;				*/
/*	justify-content:center;		*/
/*	align-items:center;			*/
}

.cvs
{
	width:90vh;					/* vh or vw ??? maybe do some media queries ?*/
	height:90vh;
	touch-action:none;			/* for mobile */
		background-color:none;

	position:absolute;			/* vertical centering */
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);
	
}

.glcvs
{
	width:90vh;					/* vh or vw ??? maybe do some media queries ?*/
	height:90vh;
/*	background-color:#fff;	*/
	touch-action:none;			/* for mobile */

	position:absolute;			/* vertical centering */
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);

}

	/* keep the canvas square and centered vertically using media queries :-) */
	
@media screen and (orientation:landscape)
{
	.cvs
	{
		width:90vh;					/* vh or vw ??? maybe do some media queries ?*/
		height:90vh;
	}

	.glcvs
	{
		width:90vh;					/* vh or vw ??? maybe do some media queries ?*/
		height:90vh;
	}
}

@media screen and (orientation:portrait)
{
	.cvs
	{
		width:90vw;					/* vh or vw ??? maybe do some media queries ?*/
		height:90vw;
	}

	.glcvs
	{
		width:90vw;					/* vh or vw ??? maybe do some media queries ?*/
		height:90vw;
	}
}

</style>

<script src="./js/vector.js"></script>
<script src="./js/matrix.js"></script>
<script src="./js/camera.js"></script>
<script src="./js/c3d.js"></script>
<script src="./js/drawlist2.js"></script>
<script src="./js/frame_counter.js"></script>
<script src="./js/inverse_projection.js"></script>

<script>
	
var ROTATE_SPEED = 5;			// must be a factor of 90.
	
var am=0;
var ANIM_MODE_NONE = am++;
var ANIM_MODE_ROTATE = am++;
var ANIM_MODE_SELECT = am++;

var emm=0;
var MOUSE_MODE_NONE = emm++;
var MOUSE_MODE_ROTATE_VIEW = emm++;
var MOUSE_MODE_SELECT = emm++;

var MouseStartSelectX;
var MouseStartSelectY;
var MouseStartSelectZ;
var SelectSurfaceNumber;



var MouseMode = MOUSE_MODE_NONE;

var CUBE_SIZE = 2;
var HCS = (CUBE_SIZE/2);		// half cube size

var NEAR_Z = 5;
var FAR_Z = 100;
var FOV = 30;

var Cvs;
var Ctx;

var CubeVertices = [];		// an array of x,y,z coordinates.
var CubeFaces = [];			// an array of indices 3 per face.
var CubeInks = [];			// r,g,b data for each vertex.
var CubeNormals = [];		// normals (x,y,z), one for each face.

var DrawList;

var Camera;
var CameraAngleYAxis = 0;
var CameraAngleXAxis = 0;
var CameraDistance = 14;

var MouseX = 0;
var MouseY = 0;

var AnimationMode = ANIM_MODE_NONE;
var AnimationAngle = 0;


var PointX = 0;
var PointY = 0;

var IncAngleX = 0;
var IncAngleY = 0;
var IncAngleZ = 0;

//var CubeRotateList = [1,3,5,7];
var CubeRotateList = [0,2,4,6];
//var CubeRotateList = [0,2,4,6];
//var CubeRotateList = [0,2,4,6];
//var CubeRotateList = [0,2,4,6];



var pick_cube = 
[
		// define all 24 vertices (4 per side)
	-CUBE_SIZE, CUBE_SIZE, CUBE_SIZE,		// front
	CUBE_SIZE, CUBE_SIZE, CUBE_SIZE,
	CUBE_SIZE, -CUBE_SIZE, CUBE_SIZE,
	-CUBE_SIZE, -CUBE_SIZE, CUBE_SIZE,
	
	-CUBE_SIZE, CUBE_SIZE, -CUBE_SIZE,		// back.
	CUBE_SIZE, CUBE_SIZE, -CUBE_SIZE,
	CUBE_SIZE, -CUBE_SIZE, -CUBE_SIZE,
	-CUBE_SIZE, -CUBE_SIZE, -CUBE_SIZE
];


var pick_cube_triangles =
[
	1,0,2,	// back
	2,3,0,
	
	5,1,2,	// right
	2,6,5,
	
	4,5,6,	// front
	6,7,4,
	
	0,4,7,	// left
	7,3,0,
	
	0,1,5,	// top
	5,4,0,

	6,7,3,	// bottom
	3,2,6
];

var pick_cube_inks =
[
	0.9, 0.9, 0.9, 		// 0
	0.9, 0.9, 0.9, 
	0.9, 0.9, 0.9, 
	
	0.9, 0.9, 0.9,		// 1
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,	// 2
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,	// 3
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,	// 4
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,


	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,


	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,


	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

];



function STRUCT_CUBE (object_id, vertices, x,y,z)
{
	var i;

	this.object_id = object_id;
	
	this.vertices = vertices.slice();		// copy the vertices.

	this.x = x;
	this.y = y;
	this.z = z;

	this.rx = 0;
	this.ry = 0;
	this.rz = 0;
	
}

var Cubes = [];

var InitialCubePositions = 	// these positions are the center of each cube.
[
	-HCS,-HCS, HCS,
	HCS,-HCS,HCS,

	-HCS,HCS,HCS,
	HCS,HCS,HCS,


	-HCS,-HCS,-HCS,
	HCS,-HCS,-HCS,

	-HCS,HCS,-HCS,
	HCS,HCS,-HCS
];
	// ---------------------------------------
	//			--- Cube Test Data ---
	// ---------------------------------------
	// note : there are shared vertices here.

//var CubeID;
var CubeIDList = [0,1,2,3,4,5,6,7];

var cube_vertices =
[
	-1, 1,-1,		// front 4 vertices
	 1, 1,-1,
	 1,-1,-1,
	-1,-1,-1,

	 1, 1, 1,		// back vertices.,0,0,
	-1, 1, 1,
	-1,-1, 1,
	 1,-1, 1,

	-1, 1, 1,		// left faces
	-1, 1,-1,
	-1,-1,-1,
	-1,-1, 1,

	 1, 1,-1,		// right faces
	 1, 1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1, 1,		// top faces
	 1, 1, 1,
	 1, 1,-1,
	-1, 1,-1,

	// bottom faces
	-1,-1,-1,
	 1,-1,-1,
	 1,-1, 1,
	-1,-1, 1
];


var cube_faces =
[
	0,1,2,
	2,3,0,

	4,5,6,
	6,7,4,

	9,10,8,
	10,11,8,

	12,13,14,
	12,14,15,

	16,17,18,
	16,18,19,

	20,21,22,
	23,20,22
];

var cube_inks =
[
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,
	0.9, 0.9, 0.9,

	0.9, 0.9, 0.0,
	0.9, 0.9, 0.0,
	0.9, 0.9, 0.0,
	0.9, 0.9, 0.0,

	0.9, 0.0, 0.9,
	0.9, 0.0, 0.9,
	0.9, 0.0, 0.9,
	0.9, 0.0, 0.9,

	0.0, 0.9, 0.9,
	0.0, 0.9, 0.9,
	0.0, 0.9, 0.9,
	0.0, 0.9, 0.9,

	0.1, 0.9, 0.2,
	0.1, 0.9, 0.2,
	0.1, 0.9, 0.2,
	0.1, 0.9, 0.2,

	0.9, 0.2, 0.1,
	0.9, 0.2, 0.1,
	0.9, 0.2, 0.1,
	0.9, 0.2, 0.1
];

var cube_normals =[];


function CalcCamera (inc_x_axis, inc_y_axis)
{
	// moves a camera using polar style coordinates.

	var x;
	var y;
	var z;
	var a;
	
	var tx;
	var ty;
	var tz;
	
	var sin_a;
	var cos_a;

	CameraAngleYAxis += inc_y_axis;
	CameraAngleXAxis += inc_x_axis;
	
		// keep ranges from -360 to + 360
	if (CameraAngleXAxis >= 90)
	{
		CameraAngleXAxis = 90;
	}

	if (CameraAngleXAxis < -90)
	{
		CameraAngleXAxis = -90
	}

//	CameraAngleYAxis = CameraAngleYAxis % 180;
//	CameraAngleXAxis = CameraAngleXAxis % 90;

	x = 0;
	y = 0;
	z = CameraDistance;

		// rotate around the x axis first.
	a = CameraAngleXAxis * Math.PI / 180;
	tx = 0;
	ty = z * Math.sin(a);	// - (y * cos_a);
	tz = z * Math.cos(a);	// + (y * sin_a);

	x = tx;
	y = ty;
	z = tz;

		// rotate around the y axis
	a = CameraAngleYAxis * Math.PI / 180;
	tx = (x * Math.cos(a)) - (z * Math.sin(a));
	ty = y;
	tz = (x * Math.sin(a)) + (z * Math.cos(a));

	x = tx;
	y = ty;
	z = tz;

//	console.log ("z:" + z);
//	x = 0;
//	y = CameraDistance * Math.sin(a);
//	z = CameraDistance * Math.cos(a);
	
	

		// now rotate around the y axis.
//	a = CameraAngleYAxis * Math.PI / 180;		// to radians.
//	x = CameraDistance * Math.sin(a);
//	y = CameraDistance
//	z = 0;

	Camera.setCamera (x,y,z, 0,0,0);

}
	// -------------------------------------------
	//		---- line drawing wrappers ----
	// -------------------------------------------
	
var LineBuffer = [];
var LineX0;
var LineY0;
var LineX1;
var LineY1;

function StartDrawLines()
{
	LineBuffer = [];
	LineX0 = -1;
	LineY0 = -1;
	LineX1 = -1;
	LineY1 = -1;
}

function MoveTo (x,y)
{
	LineX0 = x;
	LineY0 = y;
}

function LineTo (x,y)
{
	var i;

	LineX1 = x;
	LineY1 = y;
	
	i = LineBuffer.length;
	LineBuffer[i++] = LineX0;
	LineBuffer[i++] = LineY0;
	LineBuffer[i++] = LineX1;
	LineBuffer[i++] = LineY1;
	
	LineX0 = LineX1;
	LineY0 = LineY1;
}

function DrawLines()
{
	C3D_DrawLineList (LineBuffer, 255,128,0);
}

	// ---------------------------------------------------
	//		---- Cube Object Generating Routines -----
	// ---------------------------------------------------

	
function V_STRUCT (x,y,z)
{
	this.x = x;
	this.y = y;
	this.z = z;
}

function RotateVertex (x,y,z, ax, ay, az, v_struct)
{
	// rotates a vertex (x,y,z) about the origin axes and returns the result in v_struct
	// ax, ay, az are the angles in degrees.
	
	var a;
	var sin_a;
	var cos_a;
	var vx;
	var vy;
	var vz;
	var tx;
	var ty;
	var tz;

	vx = x;
	vy = y;
	vz = z;
	
	if (ax != 0)
	{
		a = ax * Math.PI / 180;		// convert to radians.
	
		sin_a = Math.sin(a);
		cos_a = Math.cos(a);

		tx = vx;
		ty = (vy * cos_a) - (vz * sin_a);
		tz = (vy * sin_a) + (vz * cos_a);

		vx = tx;
		vy = ty;
		vz = tz;
	}

	if (ay != 0)
	{
		a = ay * Math.PI / 180;
	
		sin_a = Math.sin(a);
		cos_a = Math.cos(a);

		tx = (vx * cos_a) - (vz * sin_a);
		ty = vy;
		tz = (vx * sin_a) + (vz * cos_a);

		vx = tx;
		vy = ty;
		vz = tz;
	}

	if (az != 0)
	{
		a = az * Math.PI / 180;
	
		sin_a = Math.sin(a);
		cos_a = Math.cos(a);
		
		tx = (vx * cos_a) - (vy * sin_a);
		ty = (vx * sin_a) + (vy * cos_a);
		tz = vz;

		vx = tx;
		vy = ty;
		vz = tz;
	}

	v_struct.x = vx;
	v_struct.y = vy;
	v_struct.z = vz;
}

function DrawP (ctx, p, ink)
{
	var i;
	var s;
	var x;
	var y;
	var ox;
	var oy;
	
	
	s = 100;
	
	ox = ctx.canvas.width/2;
	oy = ctx.canvas.height/2;

	ctx.beginPath();
	ctx.strokeStyle = ink;

	for (i = 0; i < p.length; i += 9)
	{
		x = ox + (p[i+0] * s);
		y = oy - (p[i+1] * s);
		ctx.moveTo (x,y);

		x = ox + (p[i+3] * s);
		y = oy - (p[i+4] * s);
		ctx.lineTo (x,y);

		x = ox + (p[i+6] * s);
		y = oy - (p[i+7] * s);
		ctx.lineTo (x,y);

		x = ox + (p[i+0] * s);
		y = oy - (p[i+1] * s);
		ctx.lineTo (x,y);
	}
	
	ctx.stroke();
}

function DrawP2 (ctx, p, ink)
{
	var line_list;
	var i;
	var s;
	var x;
	var y;
	var ox;
	var oy;
	var n;
	
	s = 100;
	
	line_list = [];
	n = 0;

	ox = ctx.canvas.width/2;
	oy = ctx.canvas.height/2;

	StartDrawLines();

	for (i = 0; i < p.length; i += 9)
	{
		x = ox + (p[i+0] * s);
		y = oy - (p[i+1] * s);
		MoveTo (x,y);
		x = ox + (p[i+3] * s);
		y = oy - (p[i+4] * s);
		LineTo (x,y);
		x = ox + (p[i+6] * s);
		y = oy - (p[i+7] * s);
		LineTo (x,y);
		x = ox + (p[i+0] * s);
		y = oy - (p[i+1] * s);
		LineTo (x,y);
	}
	DrawLines();
}


function GenerateCubeVertices(vertex_array, face_array, ink_array)
{
	// generates a set of vertices for a unit cube, each side
	// containing a coloured center.
	
	// coordinates are all centered around the local origin
	
	var border_size;
	var cube_size;
	var half_cube_size;
	var outer_left_x;
	var outer_right_x;
	var outer_top_y;
	var outer_bottom_y;
	var inner_left_x;
	var inner_right_x;
	var inner_top_y;
	var inner_bottom_y;
	var i;
	var z;
	var p;
	var v;
	var lp;
	var n;
	
	
	var _cbeinks = 
	[
		0,255,0,		// green
		255,255,255,	// white.
		0,0,255,		// blue
		255,255,0,		// yellow
		128,0,0,		// red
		255,128,0,		// orange
		
	]

	cube_size = CUBE_SIZE;
	border_size = cube_size * 0.1;
	half_cube_size = cube_size / 2;

	outer_left_x = -half_cube_size;
	outer_right_x = outer_left_x + cube_size;
	outer_top_y = half_cube_size;
	outer_bottom_y = outer_top_y - cube_size;
	
	inner_left_x = outer_left_x + border_size;
	inner_right_x = outer_right_x - border_size;
	inner_top_y = outer_top_y - border_size;
	inner_bottom_y = outer_bottom_y + border_size;

	z = half_cube_size;

//	Create Points list for a side.

	i = 0;
	p = [];

//	+---------+		// generate triangles based on the quads shown
//	|\   a   /|		// in this diagram.
//	| +-----+ |		// <<--
//	|d|  e  |b|
//	| +-----+ |
//	|/   c   \|
//	+---------+
	
		// a
	p [i++] = outer_left_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = outer_right_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = outer_right_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_top_y;
	p [i++] = z;

		// b
//	+---------+
//	|\   a   /|
//	| +-----+ |
//	|d|  e  |b|
//	| +-----+ |
//	|/   c   \|
//	+---------+

	p [i++] = outer_right_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = outer_right_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = outer_right_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_top_y;
	p [i++] = z;

//	+---------+
//	|\   a   /|
//	| +-----+ |
//	|d|  e  |b|
//	| +-----+ |
//	|/   c   \|
//	+---------+

	// c

	p [i++] = outer_right_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = outer_left_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = outer_left_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	// d
//	+---------+
//	|\   a   /|
//	| +-----+ |
//	|d|  e  |b|
//	| +-----+ |
//	|/   c   \|
//	+---------+

	p [i++] = outer_left_x;
	p [i++] = outer_bottom_y;
	p [i++] = z;

	p [i++] = outer_left_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = outer_left_x;
	p [i++] = outer_top_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_top_y;
	p [i++] = z;


	p [i++] = inner_left_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	// e
//	+---------+
//	|\   a   /|
//	| +-----+ |
//	|d|  e  |b|
//	| +-----+ |
//	|/   c   \|
//	+---------+

	p [i++] = inner_left_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_top_y;
	p [i++] = z;

	p [i++] = inner_right_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

	p [i++] = inner_left_x;
	p [i++] = inner_bottom_y;
	p [i++] = z;

//	DrawP (Ctx, p, "#777");
//	DrawP2 (Ctx, p, "#777");
	
		// generate 3D data from 2d points array.

	v = new V_STRUCT (0,0,0);
	i = 0;
	for (lp = 0; lp < 360; lp += 90)
	{
		for (n = 0; n < p.length; n+= 3)
		{
			v.x = p[n+0];
			v.y = p[n+1];
			v.z = p[n+2];
			
			RotateVertex (v.x, v.y, v.z, 0, 90, lp, v);
//			RotateVertex (v.x, v.y, v.z, 0, 270, 0, v);


			if (n == 0)
			{
				console.log ("lp:" + lp + " x:" + v.x + " y: " + v.y + " z:" + v.z);
			}
		
			vertex_array[i++] = v.x;
			vertex_array[i++] = v.y;
			vertex_array[i++] = v.z;

//			DrawP (Ctx, vertex_array, "#FF0");
		}
	}

	for (lp = 0; lp < 360; lp += 180)
	{
		for (n = 0; n < p.length; n+= 3)
		{
			v.x = p[n+0];
			v.y = p[n+1];
			v.z = p[n+2];

			RotateVertex (v.x, v.y, v.z, lp, 0, 0, v);
//			RotateVertex (v.x, v.y, v.z, 0, 0, 0, v);
		
			vertex_array[i++] = v.x;
			vertex_array[i++] = v.y;
			vertex_array[i++] = v.z;

//			DrawP (Ctx, vertex_array, "#FF0");
		}
	}
	
		// since there are no shared vertices, each face is made
		// up of 3 unique vertices.

//	for (lp = 0; lp < Math.floor (p.length/3); lp++)
	for (lp = 0; lp < Math.floor (vertex_array.length/3); lp++)
	{
		face_array[lp] = lp;
	}
	
		// each face is made up of 4 outer rectangles (8 triangles)
		// and one inner rectangle (2 triangles).
		// need to set the outer rectangles to black, and the
		// remaining two to a colour.

	i = 0;
	for (n = 0; n < 6; n++)
	{
		for (lp = 0; lp < (4*2*3); lp++)
		{
			ink_array[i++] = 0;
			ink_array[i++] = 0;
			ink_array[i++] = 0;
		}
		for (lp = 0; lp < (2*3); lp++)
		{
			ink_array[i++] = _cbeinks[(n*3)+0];
			ink_array[i++] = _cbeinks[(n*3)+1];
			ink_array[i++] = _cbeinks[(n*3)+2];
		}
	}
}

function DrawListTests()
{
	var k;
	var drawlist;

	drawlist = new STRUCT_DRAW_LIST (
				0,		// near_z
				9999,	// far z
				1024,	// number of buckets
				16,	// number of items,
				);
	
	drawlist.add (100, 10);
	drawlist.add (99, 20);
	drawlist.add (500, 5);

	drawlist.add (50, 1);
	drawlist.add (60, 1.5);

	drawlist.add (70, 999);
	
	k = [];
	
	drawlist.generateList (k);

	console.log (k);
	
	drawlist.clear();
	
	drawlist.add (2, 80);
	drawlist.add (4, 70);
	drawlist.add (6, 60);
	drawlist.add (8, 50);
	drawlist.add (10, 40);
	drawlist.add (12, 30);
	drawlist.add (14, 20);
	drawlist.add (16, 10);
	
	k = [];
	drawlist.generateList (k);
	console.log (k);
	
}

function InitCamera()
{
	Camera = new Cam3D(
						0,0,11,		// pos (x,y,z)
						0,1,0,			// up vector (0,1,0)
						0,0,0);			// look at vector (x,y,z)

	CalcCamera (0, 0);
}

function LineTest()
{
	var line_data = 
	[
		10,10, 300,250,
		400,30, 700, 100
	];
	
	var r;
	var g;
	var b;
	
	r = 255;
	g = 0;
	b = 0;

	C3D_DrawLineList (line_data, r,g,b);
}

function CalcModelMatrix (camera, tx,ty,tz, rx,ry,rz, sx,sy,sz)	//, cam_x, cam_y, cam_z, look_x, look_y, look_z)
{
	// used to combine the camera and model matrix for an object in a scene.

	// tx,ty,tz = translation coords for model.
	// rx,ry,rz = rotation about local axis
	// sx,sy,sz = scaling for model
	// cam_x, cam_y, cam_z		= camera position
	// look_x, look_y, look_z = camera look direction

	var mm;
	
	mm = MatrixIdentity();
	mm = MatrixScale (mm,sx,sy,sz);
	mm = MatrixRotate (mm, rx,ry,rz);
	mm = MatrixTranslate (mm, tx,ty,tz);

//	Camera.setCamera (cam_x, cam_y, cam_z, look_x, look_y, look_z);
	
//	mm = MatrixMultiply (Camera.cam_matrix, mm);

	mm = MatrixMultiply (camera.cam_matrix, mm);

	return mm;
}

function DrawObject (object_id, tx,ty,tz, rx,ry,rz, sx,sy,sz)
{
//	var ob_x;
//	var ob_y;
//	var ob_z;
	
	var model_matrix;
	var normal_matrix;
	
	model_matrix = CalcModelMatrix (Camera, tx,ty,tz, rx,ry,rz, sx,sy,sz);	//, cam_x, cam_y, cam_z, look_x, look_y, look_z)
	normal_matrix = CalcNormalMatrix(rx, ry, rz);
	
	C3D_DrawObject (object_id, model_matrix, normal_matrix);
}

function RotateCubePos (cube, ax, ay, az,  rx, ry, rz)
{
		// rotates & positions a cube about the axis (ax,ay,az);

	var a;
	var sin_a;
	var cos_a;

	var tx;
	var ty;
	var tz;
	
	cube.x -= ax;
	cube.y -= ay;
	cube.z -= az;

	if (rx != 0)
	{
		tx = cube.x;	ty = cube.y;	tz = cube.z;

		a = rx * Math.PI / 180;		// convert to radians.
	
		sin_a = Math.sin(a);	cos_a = Math.cos(a);

		cube.x = tx;
		cube.y = (ty * cos_a) - (tz * sin_a);
		cube.z = (ty * sin_a) + (tz * cos_a);
	}

	if (ry != 0)
	{
		tx = cube.x;	ty = cube.y;	tz = cube.z;

		a = ry * Math.PI / 180;
	
		sin_a = Math.sin(a);	cos_a = Math.cos(a);

		cube.x = (tx * cos_a) - (tz * sin_a);
		cube.y = ty;
		cube.z = (tx * sin_a) + (tz * cos_a);
	}

	if (rz != 0)
	{
		tx = cube.x;	ty = cube.y;	tz = cube.z;

		a = rz * Math.PI / 180;
	
		sin_a = Math.sin(a);	cos_a = Math.cos(a);
		
		cube.x = (tx * cos_a) - (ty * sin_a);
		cube.y = (tx * sin_a) + (ty * cos_a);
		cube.z = tz;
	}

	cube.x += ax;
	cube.y += ay;
	cube.z += az;

}

function Draw2DInfo()
{
	var ox;
	var oy;
	var v;
	var x;
	var y;
	var s;
	
	v = [0,0,0,0];
	
	C3D_CalcPickRay (Camera, MouseX, MouseY, v);

		// draw screen axes.

	Ctx.strokeStyle="#999";
	Ctx.moveTo ((Ctx.canvas.width/2), 0);
	Ctx.lineTo ((Ctx.canvas.width/2), Ctx.canvas.height);
	Ctx.moveTo (0, (Ctx.canvas.height/2));
	Ctx.lineTo (Ctx.canvas.width, (Ctx.canvas.height/2));
	Ctx.stroke();
/*
		// FOR DEBUGGING : DO NOT DELETE 
	ox = 70;
	oy = 200;
	s = 10;
	
			// draw origin
	Ctx.strokeStyle="#FF0";
	Ctx.beginPath();
	Ctx.rect(ox-3,oy-3,6,6);
	Ctx.stroke();

	x = ox + (Camera.pos.x * s);
	y = oy + (Camera.pos.z * s);
	Ctx.fillStyle="#FFF";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();

	x = ox + (v[0] * s);
	y = oy + (v[2] * s);
	Ctx.fillStyle="#F0F";
	Ctx.beginPath();
	Ctx.moveTo (x,y);
	Ctx.lineTo (x + (v[3] * 5 * s), y + (v[5] * 5 * s));
	Ctx.stroke();
*/

}

/*
function Draw2DInfoOld()
{
	var txt;
	var item;

	var ox;
	var oy;
	var s;
	var x;
	var y;

	var mx;
	var my;

	var im;
	var v;
	var z;
	var w;
	
	item = document.getElementById ("overlay");
	
	Ctx.strokeStyle="#999";
	Ctx.moveTo ((Ctx.canvas.width/2), 0);
	Ctx.lineTo ((Ctx.canvas.width/2), Ctx.canvas.height);
	Ctx.moveTo (0, (Ctx.canvas.height/2));
	Ctx.lineTo (Ctx.canvas.width, (Ctx.canvas.height/2));
	Ctx.stroke();
	
	ox = 70;
	oy = 200;
	s = 10;

		// draw origin
	Ctx.strokeStyle="#FF0";
	Ctx.beginPath();
	Ctx.rect(ox-3,oy-3,6,6);
	Ctx.stroke();

//	mx = Ctx.canvas.width/2;	//MouseX;	//Ctx.canvas.width;
	mx = MouseX;
	my = Ctx.canvas.height/2;	//MouseY;
//	my = MouseY;

	txt = "mx:" + mx + " my:" + my + "<br>";

	mx = mx / Ctx.canvas.width;
	my = my / Ctx.canvas.height;
	
	txt += "mx[0..1]:" + mx + " my[0..1]:" + my + "<br>";
	
	mx =( mx * 2) - 1;
	my = 1 - (my * 2);

	txt += "mx[-1..1]:" + mx + " my[-1..1]:" + my + "<br>";
	
	z =0;		// range for z is [-1..1] (open gl) or [0..1] direct x .	glu unproject actually converts winz from [0..1] to [-1..1] using 2 * winz - 1. so i suspect directx does the same
	w = 1;
	v = [mx, my, z, w];

	txt += "v [x,y,z,w] <br>";
	txt += "v[0]:" + v[0] + "<br> v[1]:" + v[1] + "<br> v[2]:" + v[2] + "<br> v[3]:" + v[3] + "<br>";
	
	v = MatrixVectorMultiply (_C3D_InversePerspectiveMatrix, v);

	txt += "v x ipm: <br>";

	txt += "v[0]:" + v[0] + "<br> v[1]:" + v[1] + "<br> v[2]:" + v[2] + "<br> v[3]:" + v[3] + "<br>";

	txt += "v / w: <br>";

	v[0] /= v[3];
	v[1] /= v[3];

	txt += "v[0]:" + v[0] + "<br> v[1]:" + v[1] + "<br> v[2]:" + v[2] + "<br> v[3]:" + v[3] + "<br>";

	x = ox + (Camera.pos.x * s);
	y = oy + (Camera.pos.z * s);
	Ctx.fillStyle="#FFF";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();
	
	x = ox + (v[0] * s * 10);
	y = oy - (v[2] * s);
	Ctx.fillStyle="#F00";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();

	im = MatrixIdentity();
	Matrix4x4Inverse (Camera.cam_matrix, im);

	v = MatrixVectorMultiply (im, v);

	txt += "v * icm:<br>";
	txt += "v[0]:" + v[0] + "<br> v[1]:" + v[1] + "<br> v[2]:" + v[2] + "<br> v[3]:" + v[3] + "<br>";

	x = ox + (v[0] * s);
	y = oy + (v[2] * s);
	Ctx.fillStyle="#F0F";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();


	item.innerHTML = txt;
}
*/

/*
		// draw camera pos.
	x = ox + (Camera.pos.x * s);
	y = oy - (Camera.pos.z * s);
	Ctx.fillStyle="#FFF";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();

	x = ox + PointX;
	y = oy - PointY;
	Ctx.fillStyle="#FFF";
	Ctx.beginPath();
	Ctx.rect (x-2, y-2, 4,4);
	Ctx.fill();
	
//	0 4 8 12
//	1 5 9 13
//	2 6 10 14
//	3 7 11 15

	txt.innerHTML = "tx:" + Camera.cam_matrix[12] + " <br>ty:" + Camera.cam_matrix[13] + " <br>tz:" + Camera.cam_matrix[14];
}
*/	

function BakeCube (cube_index)
{
	// updates the cube vertices with the current rotation and then
	// sets the rotation back to zero.

	var c;
	var v;
	var x;
	var y;
	var z;
	
	v = new V_STRUCT (0,0,0);

//	console.log ("ci:" + cube_index + "=====================================");
	
	c = Cubes[cube_index]
	for (i = 0; i < c.vertices.length; i+= 3)
	{
		x = c.vertices[i+0];
		y = c.vertices[i+1];
		z = c.vertices[i+2];

//		console.log ("x:" + x + " y:" + y + " z:" + z);

		RotateVertex (x, y, z, -c.rx, c.ry, -c.rz, v);

//		console.log ("vx:" + v.x + " vy:" + v.y + " vz:" + v.z);

		c.vertices[i+0] = v.x;
		c.vertices[i+1] = v.y;
		c.vertices[i+2] = v.z;

	}
	
	c.rx = 0;
	c.ry = 0;
	c.rz = 0;
	
	C3D_UpdateVertices (c.object_id, c.vertices, 0, Math.floor (c.vertices.length/3));

}


var busy = false;
//var r = 0;
function AnimLoop (t)
{
	var g;
	var i;
	var c;
	var x;
	var y;
	var z;
	var rx;
	var ry;
	var rz;

	if (busy == true)	return;
	busy = true;

	C3D_ClearCanvas();
	
	if ((CubeRotateList.length < 0) || ((IncAngleX | IncAngleY | IncAngleZ) == 0))
	{
			// need this to prevent lock up.
		AnimationMode = ANIM_MODE_NONE;
	}

	if (AnimationMode == ANIM_MODE_ROTATE)
	{
		for (g = 0; g < CubeRotateList.length; g++)
		{
			i = CubeRotateList[g];
			RotateCubePos (Cubes[ i ],
						0,0,0,			// ax, ay, az
						IncAngleX,-IncAngleY,IncAngleZ,	//rx, ry, rz)
						);

			Cubes[i].rx += -IncAngleX;
			Cubes[i].ry += -IncAngleY;
			Cubes[i].rz += -IncAngleZ;
		}

		AnimationAngle += Math.abs(IncAngleX);
		AnimationAngle += Math.abs(IncAngleY);
		AnimationAngle += Math.abs(IncAngleZ);

		if (AnimationAngle >= 90)
		{
			AnimationMode = ANIM_MODE_NONE;
			AnimationAngle = 90;
			// clamp positions to whole number
			for (g = 0; g < CubeRotateList.length; g++)
			{
				i = CubeRotateList[g];
				Cubes[i].x = Math.floor (Cubes[i].x + 0.5);
				Cubes[i].y = Math.floor (Cubes[i].y + 0.5);
				Cubes[i].z = Math.floor (Cubes[i].z + 0.5);
				
				BakeCube (i);

			}
			
			MouseMode = MOUSE_MODE_NONE;
		}
	}

//	console.log ("l:" + CubePositions.length);
	for (g = 0; g < Cubes.length; g++)
	{
		c = Cubes[g];

//		DrawObject (CubeID,
//		console.log ("g:" + g + " >> " + CubeIDList[g]);
		DrawObject (CubeIDList[g],
					c.x, c.y, c.z,			// position
					c.rx, c.ry, c.rz,			// rotation
					1, 1, 1);		// scale
	}

	Draw2DInfo();

//	r++;
	C3D_DrawDrawList ();
	
	
//	C3D_Picking (Camera, MouseX, MouseY);


	
	busy = false;
	requestAnimationFrame (AnimLoop);
}

function InitCubes()
{
	var n;
	var x;
	var y;
	var z;
	var i;
	var object_id;
	
	
	i = 0;
	for (n = 0; n < 8; n++)
	{
		object_id = CubeIDList[n];

		x = InitialCubePositions[i++];
		y = InitialCubePositions[i++];
		z = InitialCubePositions[i++];
		Cubes[n] = new STRUCT_CUBE (object_id, CubeVertices, x,y,z);
	}
}

function CalcNormalMatrix(rx, ry, rz)
{
	// normal matrix is just the set of rotations, with no scaling or 
	// translation.

	var mm;
	
	mm = MatrixIdentity();
	mm = MatrixRotate (mm, rx,ry,rz);

	return mm;
}


function DrawTest()
{
	DrawObject (CubeID,
					0,0,0,			// position
					0,0,30,			// rotation
					1, 1, 1);		// scale


	C3D_DrawDrawList ();

}

function LoadModelData()
{
	var i;

	GenerateCubeVertices (CubeVertices,  CubeFaces,  CubeInks);
	C3D_CreateNormals (CubeVertices, CubeFaces, CubeNormals);

	for (i = 0; i < 8; i++)
	{
		CubeIDList[i] = C3D_UploadModelData (CubeVertices, CubeFaces, CubeInks, null, null);
	}
//	CubeID = C3D_UploadModelData (CubeVertices, CubeFaces, CubeInks, null, null);

}

/*
function PickTest (mx, my)
{
	var cube_width;
	var cube_height;
//	C3D_Picking (Camera, mx, my);
	var pick_ray;
	var i;
	var nearest_idx;
	var nearest_d;
	var z;
	var t;
	var n;
	
	var v0;
	var v1;
	var v2;

	var x0;
	var y0;
	var z0;
	var x1;
	var y1;
	var z1;
	var x2;
	var y2;
	var z2;
	
	var rx;
	var ry;
	var rz;
	
	var rdx;
	var rdy;
	var rdz;
	
	var d;
	
	var r;

	var p;
	
	console.log ("pick test");
	
	pick_ray = [0,0,0,0,0,0];
	
	C3D_CalcPickRay (Camera, mx, my, pick_ray);

	rx = pick_ray[0];
	ry = pick_ray[1];
	rz = pick_ray[2];
	
	rdx = pick_ray[3];
	rdy = pick_ray[4];
	rdz = pick_ray[5];
	
	console.log ("rx:" + rx + " ry:" + ry + " rz:" + rz +  " dx:" + rdx + " dy:" + rdy + " dz:" + rdz);

	p = new Vector(0,0,0);
//var pick_cube = 
//var pick_cube_triangles =

	nearest_d = (FAR_Z*FAR_Z)*3;
	nearest_idx = -1;
	for (n = 0; n < pick_cube_triangles.length; n += 3)
//	n  = 0;
	{
		v0 = pick_cube_triangles[n+0];
		v1 = pick_cube_triangles[n+1];
		v2 = pick_cube_triangles[n+2];
		
//		console.log ("v0:" + v0 + " v1:" + v1 + " v2:" + v2);
		
		v0 *= 3;
		v1 *= 3;
		v2 *= 3;
	
		x0 = pick_cube [v0 + 0];
		y0 = pick_cube [v0 + 1];
		z0 = pick_cube [v0 + 2];

		x1 = pick_cube [v1 + 0];
		y1 = pick_cube [v1 + 1];
		z1 = pick_cube [v1 + 2];

		x2 = pick_cube [v2 + 0];
		y2 = pick_cube [v2 + 1];
		z2 = pick_cube [v2 + 2];

		r = C3D_RayTriangleIntersection (rx,ry,rz, rdx, rdy, rdz, x0,y0,z0, x1,y1,z1, x2,y2,z2, p);	
		if (r == true)
		{
			console.log ("hit! : " + Math.floor (n/3) + "  :: cx: " + Camera.pos.x + " cy:" + Camera.pos.y + " cz:" + Camera.pos.z);
			console.log (p);
			d = (
							(p.x - Camera.pos.x)*(p.x - Camera.pos.x) + 
							(p.y - Camera.pos.y)*(p.y - Camera.pos.y) + 
							(p.z - Camera.pos.z)*(p.z - Camera.pos.z));
			if (d < nearest_d)
			{
				nearest_d = d;
				nearest_idx = Math.floor (n/3);
			}
		}
	}
	console.log ("nearest :" + nearest_idx + " d:" + nearest_d);
}
*/

function PICK_RAY_STRUCT (x,y,z,dx,dy,dz)
{
	this.x = x;				// (x,y,z) = origin of pick ray
	this.y = y;
	this.z = z;
	
	this.dx = dx;			// (dx,dy,dz) = direction of pick ray.
	this.dy = dy;
	this.dz = dz;
	
	this.nearest_idx;		// nearest surface index.
	this.nearest_x;
	this.nearest_y;
	this.nearest_z;
}

PICK_RAY_STRUCT.prototype.calcPickRay = function (camera, mouse_x, mouse_y)
{
	var p;
	
	p = [0,0,0,0,0,0,0];

	C3D_CalcPickRay (camera, mouse_x, mouse_y, p);
	
	this.x = p[0];
	this.y = p[1];
	this.z = p[2];
	
	this.dx = p[3];
	this.dy = p[4];
	this.dz = p[5];
}

PICK_RAY_STRUCT.prototype.findNearestSurface = function (vertex_array, face_index_array)
{
	// call calcPickRay to create the pick ray itself, then call here 
	// to find the nearest intersecting surface (if it exists).
	
	// vertex array .. array of (x,y,z) values.
	// face_index_array (v0,v1,v2) array of indices into the vertex
	// array for constructing triangles (surfaces).
	
	var f;
	var v0;
	var v1;
	var v2;

	var x0;	var y0;	var z0;
	var x1;	var y1;	var z1;
	var x2;	var y2;	var z2;
	
	var p;
	var d;
	
	var nearest_d;
	var nearest_idx;

	nearest_d = (FAR_Z*FAR_Z)*3;
	nearest_idx = -1;

	p = new Vector(0,0,0);
	
	for (f = 0; f < face_index_array.length; f += 3)
	{
		v0 = face_index_array[f+0];
		v1 = face_index_array[f+1];
		v2 = face_index_array[f+2];
		
		v0 *= 3;
		v1 *= 3;
		v2 *= 3;
	
		x0 = vertex_array [v0 + 0];
		y0 = vertex_array [v0 + 1];
		z0 = vertex_array [v0 + 2];

		x1 = vertex_array [v1 + 0];
		y1 = vertex_array [v1 + 1];
		z1 = vertex_array [v1 + 2];

		x2 = vertex_array [v2 + 0];
		y2 = vertex_array [v2 + 1];
		z2 = vertex_array [v2 + 2];

		r = C3D_RayTriangleIntersection (
						this.x, this.y, this.z,
						this.dx, this.dy, this.dz,
						x0,y0,z0, x1,y1,z1, x2,y2,z2,
						p);	
		if (r == true)
		{
//			console.log ("hit! : " + Math.floor (f/3) + "  :: cx: " + Camera.pos.x + " cy:" + Camera.pos.y + " cz:" + Camera.pos.z);
//			console.log (p);
			d = (
						((p.x - this.x) * (p.x - this.x)) + 
						((p.y - this.y) * (p.y - this.y)) + 
						((p.z - this.z) * (p.z - this.z)));
						
//							(p.x - Camera.pos.x)*(p.x - Camera.pos.x) + 
//							(p.y - Camera.pos.y)*(p.y - Camera.pos.y) + 
//							(p.z - Camera.pos.z)*(p.z - Camera.pos.z));
			if (d < nearest_d)
			{
				nearest_d = d;
				nearest_idx = Math.floor (f/3);
				
				this.nearest_x = p.x;
				this.nearest_y = p.y;
				this.nearest_z = p.z;
				
//				this.nearest_x = Math.floor (p.x);
//				this.nearest_y = Math.floor (p.y);
//				this.nearest_z = Math.floor (p.z);
				
//				this.nearest_x = 1;
//				this.nearest_y = 1;
//				this.nearest_z = 1;
//				if (p.x < 0)	this.nearest_x = -1;
//				if (p.y < 0)	this.nearest_y = -1;
//				if (p.z < 0)	this.nearest_z = -1;
				
			}
		}
	}

	this.nearest_idx = nearest_idx;
	
//	console.log ("nearest:" + nearest_idx + " x:" + this.nearest_x + " y:" + this.nearest_y + " z:" + this.nearest_z);

}

function GetNearestCube (x,y,z)
{
	var i;
	var d;
	var nd;
	var idx;
	var cube;
	
	var nx;
	var ny;
	var nz;

	nx = 1;
	ny = 1;
	nz = 1;

	if (x < 0)	nx = -1;
	if (y < 0)	ny = -1;
	if (z < 0)	nz = -1;
	
	nd = 999;
	idx = -1;
	for (i = 0; i < Cubes.length; i++)
	{
		cube = Cubes[i];
		d =(
			((nx - cube.x) * (nx - cube.x)) +
			((ny - cube.y) * (ny - cube.y)) +
			((nz - cube.z) * (nz - cube.z)) );
			
		if (d < nd)
		{
			nd = d;
			idx = i;
		}
	}
	
	return idx;
}


/*function STRUCT_CUBE_POS (x,y,z)
{
	this.x = x;
	this.y = y;
	this.z = z;

	this.rx = 0;
	this.ry = 0;
	this.rz = 0;
	
}

var CubePositions = [];
*/


function SetMouseMode (mx, my)
{
		// see if the ray created by unprojecting the  mouse screen
		// coordinates (mx,my) intersects with the pick cube 
		// triangle mesh,

		// if they don't , then the mouse mode is set to rotate the
		// view (camera moves around the origin).
		
		// if they do, then a group of 4 cubes are selected and 
		// animated.
	
	var pick_ray;
	var c;

	MouseMode = MOUSE_MODE_NONE;

	pick_ray = new PICK_RAY_STRUCT (0,0,0,0,0,0);

	pick_ray.calcPickRay (Camera, mx, my);
	
	pick_ray.findNearestSurface (pick_cube, pick_cube_triangles);

	if (pick_ray.nearest_idx == -1)
	{
		MouseMode = MOUSE_MODE_ROTATE_VIEW;
		return;
	}

	c = GetNearestCube (pick_ray.nearest_x, pick_ray.nearest_y, pick_ray.nearest_z);
	if (c == -1)
	{
//		console.log ("can't locate cube");
		return;
	}
	
//	console.log ("c:" + c);

	MouseMode = MOUSE_MODE_SELECT;

	MouseStartSelectX = pick_ray.nearest_x;
	MouseStartSelectY = pick_ray.nearest_y;
	MouseStartSelectZ = pick_ray.nearest_z;

//	CubePositions[c].x += 0.5;

/*	var rx;
	var ry;
	var rz;
	
	var rdx;
	var rdy;
	var rdz;
	
	var p;
	var nearest_d;
	var nearest_idx;
	
	var v0;
	var v1;
	var v2;
	
	var x0;
	var y0;
	var z0;

	var x1;
	var y1;
	var z1;

	var x2;
	var y2;
	var z2;
	
	var r;
	var n;
	
	pick_ray = [0,0,0,0,0,0];
	
	C3D_CalcPickRay (Camera, mx, my, pick_ray);

	rx = pick_ray[0];
	ry = pick_ray[1];
	rz = pick_ray[2];
	
	rdx = pick_ray[3];
	rdy = pick_ray[4];
	rdz = pick_ray[5];
	
	console.log ("rx:" + rx + " ry:" + ry + " rz:" + rz +  " dx:" + rdx + " dy:" + rdy + " dz:" + rdz);

	p = new Vector(0,0,0);

	nearest_d = (FAR_Z*FAR_Z)*3;
	nearest_idx = -1;
	for (n = 0; n < pick_cube_triangles.length; n += 3)
	{
		v0 = pick_cube_triangles[n+0];
		v1 = pick_cube_triangles[n+1];
		v2 = pick_cube_triangles[n+2];
		
		v0 *= 3;
		v1 *= 3;
		v2 *= 3;
	
		x0 = pick_cube [v0 + 0];
		y0 = pick_cube [v0 + 1];
		z0 = pick_cube [v0 + 2];

		x1 = pick_cube [v1 + 0];
		y1 = pick_cube [v1 + 1];
		z1 = pick_cube [v1 + 2];

		x2 = pick_cube [v2 + 0];
		y2 = pick_cube [v2 + 1];
		z2 = pick_cube [v2 + 2];

		r = C3D_RayTriangleIntersection (rx,ry,rz, rdx, rdy, rdz, x0,y0,z0, x1,y1,z1, x2,y2,z2, p);	
		if (r == true)
		{
//			console.log ("hit! : " + Math.floor (n/3) + "  :: cx: " + Camera.pos.x + " cy:" + Camera.pos.y + " cz:" + Camera.pos.z);
//			console.log (p);
			d = (
							(p.x - Camera.pos.x)*(p.x - Camera.pos.x) + 
							(p.y - Camera.pos.y)*(p.y - Camera.pos.y) + 
							(p.z - Camera.pos.z)*(p.z - Camera.pos.z));
			if (d < nearest_d)
			{
				nearest_d = d;
				nearest_idx = Math.floor (n/3);
			}
		}
	}
	
	if (nearest_idx == -1)
	{
		MouseMode = MOUSE_MODE_ROTATE_VIEW;
		return;
	}
	
	// user has selected something.. decide what to do with this
	// information...

	console.log ("nearest :" + nearest_idx + " d:" + nearest_d);
//	console.log (p);

	MouseMode = MOUSE_MODE_SELECT;
	MouseStartSelectX = p.x;
	MouseStartSelectY = p.y;
	MouseStartSelectZ = p.z;
	
	SelectSurfaceNumber = Math.floor (nearest_idx/2);
*/
}

function DoMove (mx, my)
{
	var p;
	
	var d;
	var dx;
	var dy;
	var dz;
	var min_distance;
	
	var vmove;
	var hmove;
	var dmove;
	
	var left_x;			// coords used to select which 4 blocks to rotate.
	var right_x;
	var top_y;
	var bottom_y;
	var near_z;
	var far_z;
	
	var rx;
	var ry;
	var rz;
	
	var i;
	var n;

//	console.log ("---------- do move ----------------");

	rx = 0; ry = 0; rz = 0;

	min_distance = 0.4;

	p = new PICK_RAY_STRUCT (0,0,0,0,0,0);

	p.calcPickRay (Camera, mx, my);
	
	p.findNearestSurface (pick_cube, pick_cube_triangles);

	if (p.nearest_idx == -1)
	{
		return;
	}
	
	dx = p.nearest_x - MouseStartSelectX;
	dy = p.nearest_y - MouseStartSelectY;
	dz = p.nearest_z - MouseStartSelectZ;
	
//	console.log ("do move :" );
	
//	console.log ("sx:" + MouseStartSelectX);
//	console.log ("sy:" + MouseStartSelectY);
//	console.log ("sz:" + MouseStartSelectZ);
//	console.log ("x:" + p.nearest_x);
//	console.log ("y:" + p.nearest_y);
//	console.log ("z:" + p.nearest_z);
	
//	console.log ("dx:" + dx);
//	console.log ("dy:" + dy);
//	console.log ("dz:" + dz);
	
	d = Math.sqrt ((dx*dx)+(dy*dy)+(dz*dz));
//	console.log ("d:" + d);
	
	if (d < 0.4)
	{
			// distance moved needs to be above some minimum to
			// prevent accidental wrong direction selected.
		return;
	}
	
		// lots of ways to do this.. sigh...	
		
		// goal is to work out which of the six rotation combinations
		// to do:
		// top, bottom, left, right, back, front.

		// TO DO : MAKE ALL THIS TABLE DRIVEN.

	vmove = false;
	hmove = false;
	dmove = false;
	
	if ((Math.abs(dy) > Math.abs(dx)) && (Math.abs(dy) > Math.abs(dz)))
	{
//		console.log ("vertical move");
		if ( ((p.nearest_x > 0) && (MouseStartSelectX < 0)) ||
			 ((p.nearest_x < 0) && (MouseStartSelectX > 0)) ||
			 ((p.nearest_z > 0) && (MouseStartSelectZ < 0)) ||
			 ((p.nearest_z < 0) && (MouseStartSelectZ > 0)) )
		{
//			console.log ("signs dont match..");
			return;
		}
		vmove = true;
	}

	if ((Math.abs(dx) > Math.abs(dy)) && (Math.abs(dx) > Math.abs(dz)))
	{
//		console.log ("hmove");
		if ( ((p.nearest_y > 0) && (MouseStartSelectY < 0)) ||
			 ((p.nearest_y < 0) && (MouseStartSelectY > 0)) ||
			 ((p.nearest_z > 0) && (MouseStartSelectZ < 0)) ||
			 ((p.nearest_z < 0) && (MouseStartSelectZ > 0)) )
		{
//			console.log ("signs dont match..");
			return;
		}
		hmove = true;
	}

	if ((Math.abs(dz) > Math.abs(dx)) && (Math.abs(dz) > Math.abs(dy)))
	{
//		console.log ("depth move");
		if ( ((p.nearest_x > 0) && (MouseStartSelectX < 0)) ||
			 ((p.nearest_x < 0) && (MouseStartSelectX > 0)) ||
			 ((p.nearest_y > 0) && (MouseStartSelectY < 0)) ||
			 ((p.nearest_y < 0) && (MouseStartSelectY > 0)) )
		{
//			console.log ("signs dont match..");
			return;
		}
		dmove = true;
	}
	
	if (MouseStartSelectZ >= 1.99999)
	{
			// ** brown side = working
//		console.log ("brown side");
		if (dmove == true)	return;			// can't do depth move for brown side
		if (vmove == true)
		{
			rx = -1;
			if (dy < 0)	rx = 1;
			top_y = 2;		bottom_y = -2;
			near_z = -2;	far_z = 2;
			if (MouseStartSelectX < 0)
			{
//				console.log ("vmove left hand side");
				left_x = -2;	right_x = 0;
			}
			else
			{
//				console.log ("vmove  RIGHT HAND SIDE");
				left_x = 0;	right_x = 2;
			}
		}
		if (hmove == true)
		{
			ry = 1;
			if (dx < 0)	ry = -1;
			left_x = -2;	right_x = 2;
			near_z = -2;	far_z = 2;
			if (MouseStartSelectY > 0)
			{
//				console.log ("hmove top");
				top_y = 2;			bottom_y = 0;
			}
			else
			{
//				console.log ("hmove bottom");
				top_y = 0;			bottom_y = -2;
			}
		}
	}

	if (MouseStartSelectX >= 1.99999)
	{
			// ** blue side = working
//		console.log ("blue side");
		if (vmove == true)
		{
//			console.log ("vmove = true");
			rz = 1;
			if (dy < 0)	rz = -1;
			left_x = -2;	right_x = 2;
			top_y = 2;		bottom_y = -2;

			if (MouseStartSelectZ > 0)
			{
				near_z = 0;			far_z = 2;
//				console.log ("vmove front");
			}
			else
			{
//				console.log ("vmove back");
				near_z = -2;			far_z = 0;
			}

//			near_z = 0;			far_z = 2;	// T****TEST CODE ***

		}

		if (dmove == true)
		{
			ry = -1;
			if (dz < 0)	ry = 1;

			left_x = -2;	right_x = 2;
			near_z = -2;	far_z = 2;
	
			if (MouseStartSelectY > 0)
			{
//				console.log ("hmove top (blue)");
				top_y = 2;			bottom_y = 0;
			}
			else
			{
//				console.log ("hmove bottom (blue)");
				top_y = 0;		bottom_y = -2;
			}
		}
			
	}
	if (MouseStartSelectX <= -1.99999)
	{
			// ** green side = working

//		console.log ("green side");
		if (dmove == true)
		{
			ry = 1;
			if (dz < 1)	ry = -1;
			left_x = -2;	right_x = 2;
			near_z = -2;	far_z = 2;

			if (MouseStartSelectY > 0)
			{
//				console.log ("hmove top (green)");
				top_y = 2;			bottom_y = 0;
			}
			else
			{
//				console.log ("hmove bottom (green)");
				top_y = 0;			bottom_y = -2;
			}
		}
		if (vmove == true)
		{
			rz = -1;
			if (dy < 0)	rz = 1;
			left_x = -2;	right_x = 2;
			top_y = 2;		bottom_y = -2;

			if (MouseStartSelectZ > 0)
			{
//				console.log ("vmove front (green)");
				near_z = 0;			far_z = 2;
			}
			else
			{
//				console.log ("vmove back (green)");
				near_z = -2;			far_z = 0;
			}
		}
	}

	if (MouseStartSelectZ <= -1.99999)
	{
			// ** orange side = working
//		console.log ("orange side");
		if (dmove == true)	return;			// can't do depth move for orange side
		if (vmove == true)
		{
			near_z = -2;			far_z = 2;
			top_y = 2;		bottom_y = -2;

			rx = 1;
			if (dy < 0)	rx = -1;
			if (MouseStartSelectX < 0)
			{
				left_x = -2;	right_x = 0;
//				console.log ("vmove left hand side");
			}
			else
			{
//				console.log ("vmove rhs");
				left_x = 0;	right_x = 2;
			}
		}
		if (hmove == true)
		{
			ry = -1;
			if (dx < 0)	ry = 1;

			left_x = -2;	right_x = 2;
			near_z = -2;			far_z = 2;

			if (MouseStartSelectY > 0)
			{
//				console.log ("hmove top");
				top_y = 2;		bottom_y = 0;
			}
			else
			{
//				console.log ("hmove bottom");
				top_y = 0;		bottom_y = -2;
			}
		}

	}
	if (MouseStartSelectY >= 1.99999)
	{
//		console.log ("yellow side");
		if (vmove == true)	return;			// can't do vertical move for yellow side
		if (hmove == true)
		{
			rz = -1;
			if (dx < 0)	rz = 1;
			top_y = 2;		bottom_y = -2;
			left_x  =-2; right_x = 2;
			if (MouseStartSelectZ > 0)
			{
//				console.log ("hmove front (yellow)");
				near_z = 0;	far_z = 2;
			}
			else
			{
//				console.log ("hmove back (yellow)");
				near_z = -2;	far_z = 0;
			}
		}
		if (dmove == true)
		{
			rx = 1;
			if (dz < 0)	rx = -1;
			top_y = 2;		bottom_y = -2;
			near_z = -2;	far_z = 2;

			if (MouseStartSelectX > 0)
			{
//				console.log ("dmove right (yellow)");
				left_x  = 0; right_x = 2;
			}
			else
			{
//				console.log ("dmove left (yellow");
				left_x  =-2; right_x = 0;
			}
		}
	}
	if (MouseStartSelectY <= -1.99999)
	{
//		console.log ("white side");
		if (vmove == true)	return;			// can't do vertical move for white side

		if (dmove == true)
		{
			rx = -1;
			if (dz < 0)	rx = 1;
			top_y = 2;		bottom_y = -2;
			near_z = -2;	far_z = 2;
			
			if (MouseStartSelectX > 0)
			{
//				console.log ("dmove right (white)");
				left_x  = 0; right_x = 2;
			}
			else
			{
//				console.log ("dmove left (white");
				left_x  =-2; right_x = 0;
			}
		}
		if (hmove == true)
		{
			rz = 1;
			if (dx < 0)	rz = -1;
			top_y = 2;		bottom_y = -2;
			left_x  =-2; right_x = 2;
			
			if (MouseStartSelectZ > 0)
			{
//				console.log ("hmove front (white)");
				near_z = 0;	far_z = 2;
			}
			else
			{
//				console.log ("hmove back (white)");
				near_z = -2;	far_z = 0;
			}
		}
	}

	AnimationMode = ANIM_MODE_ROTATE;
	AnimationAngle = 0;

	IncAngleX = 0; IncAngleY = 0; IncAngleZ = 0;
	
	MouseMode = MOUSE_MODE_NONE;

	IncAngleX = rx * ROTATE_SPEED;
	IncAngleY = ry * ROTATE_SPEED;
	IncAngleZ = rz * ROTATE_SPEED;
	
	if (near_z > far_z)
	{
		console.log ("** ERROR nz > fz **");
	}
	
//	console.log ("lx:" + left_x + " rx:" + right_x);
//	console.log ("ty:" + top_y + " by:" + bottom_y);
//	console.log ("nz:" + near_z + " fz:" + far_z);
	i = 0;
	CubeRotateList = [];
	for (n = 0; n < Cubes.length; n++)
	{
//		console.log ("n:" + n + " x:" + Cubes[n].x + " y:" + Cubes[n].y + " z:" + Cubes[n].z);
		if ((Cubes[n].x > left_x) && (Cubes[n].x < right_x) &&
			(Cubes[n].y > bottom_y) && (Cubes[n].y < top_y) &&
			(Cubes[n].z > near_z) && (Cubes[n].z < far_z))
		{
//			console.log ("++n:" + n + " x:" + Cubes[n].x);
			CubeRotateList[i++] = n;
		}
	}
	
	if (CubeRotateList.length < 1)
	{
//		console.log ("failed to select any cubes");
		AnimationMode = ANIM_MODE_NONE;
		AnimationAngle = 0;
		MouseMode = MOUSE_MODE_NONE;
	}
		
}




function PointerDown(e)
{
	var rect;
	var cvs;
	var rw;
	var rh;
	var mx;
	var my;
	
	var h;
	var r;
	var g;
	var b;
	var i;
	
	var ctx;

	if (AnimationMode == ANIM_MODE_ROTATE)
	{
		return;
	}
	
	cvs = e.currentTarget;	//document.getElementById (CvsID);

	rect = cvs.getBoundingClientRect();

	mx = e.clientX - rect.left;
	my = e.clientY - rect.top;

	rw = rect.right - rect.left;
	rh = rect.bottom - rect.top;
	mx = Math.floor (mx * cvs.width / rw);	// scale mx to the physical canvas width.
	my = Math.floor (my * cvs.height / rh);

	MouseX = mx;
	MouseY = my;
	
	SetMouseMode (mx, my);

	e.currentTarget.setPointerCapture (e.pointerId);

	e.preventDefault();
	return false;

}

function PointerMove(e)
{
	var rect;
	var cvs;
	var ctx;
	var rw;
	var rh;
	var mx;
	var my;
	
	var h;
	var r;
	var g;
	var b;
	var i;
	
	var pm;
	
	if (AnimationMode == ANIM_MODE_ROTATE)
	{
		return;
	}

	cvs = e.currentTarget;	//document.getElementById (CvsID);

	rect = cvs.getBoundingClientRect();

	mx = e.clientX - rect.left;
	my = e.clientY - rect.top;

	rw = rect.right - rect.left;
	rh = rect.bottom - rect.top;
	mx = Math.floor (mx * cvs.width / rw);	// scale mx to the physical canvas width.
	my = Math.floor (my * cvs.height / rh);

	switch (MouseMode)
	{
		case MOUSE_MODE_ROTATE_VIEW:
					// TO DO : ROTATE CAMERA VIEW
				if (e.buttons > 0)
				{
					CalcCamera (my - MouseY,	mx - MouseX);
				}
				break;
		default: // do nothing.
			break;
	}

	MouseX = mx;
	MouseY = my;

	e.preventDefault();

}

function PointerUp (e)
{
	var rect;
	var cvs;
	var rw;
	var rh;
	var mx;
	var my;

	if (AnimationMode == ANIM_MODE_ROTATE)
	{
		return;
	}

	
	cvs = e.currentTarget;	//document.getElementById (CvsID);

	rect = cvs.getBoundingClientRect();

	mx = e.clientX - rect.left;
	my = e.clientY - rect.top;

	rw = rect.right - rect.left;
	rh = rect.bottom - rect.top;
	mx = Math.floor (mx * cvs.width / rw);	// scale mx to the physical canvas width.
	my = Math.floor (my * cvs.height / rh);

	e.currentTarget.releasePointerCapture (e.pointerId);

	if (MouseMode == MOUSE_MODE_SELECT)
	{
//		console.log ("select direction to move");
		DoMove (mx, my);
	}

	MouseMode = MOUSE_MODE_NONE;
}

function PointerCancel (e)
{
//	var b;

//	Cancelled = true;
//	DrawStatusBar();

	e.preventDefault();
	
	return false;
}

function InverseMatrixTest()
{
	// multiplies a point vector by the perspective matrix.
	// and does all the calculations you would to convert it to 
	// screen coordinates.
	
	// THEN does the reverse to see if you can get the values you
	// started with.
	
	// problem : the z information is lost when you go from 2D to 3D
	// if near z != 1, then the calculation doesn't seem to work
		
	var pm;
	var im;
	var v;
	var ox;
	var oy;
	var sw;
	var sh;
	var nz;
	var fz;

	var mx;
	var my;
	var mz;
	
	console.log ("------ inverse matrix test -----");

		// init values, create projection matrices.

	sw = 512;					// screen width
	sh = 512;					// screen height
	ox = Math.floor (sw/2);		// coordinate origin (middle of screen).
	oy = Math.floor (sh/2);
	nz = 4;						// near z.
	fz = 1000;
	
	console.log ("ox:" + ox + " oy:" + oy);

	pm = Matrix_CreatePerspectiveProjectionMatrix (
		sw, 				// width in pixels
		sh,	 			// height in pixels
		30,				// field of view (degrees)
		nz,					// near z
		fz);				// far z

//	im = MatrixIdentity();
	//Matrix4x4Inverse (pm, im);
	im = ProjectionMatrixInverse (pm);

		// step 1: world to screen calculations.

	mx = -1;
	my = 0;
	mz = 1;

	v = [mx , my, mz, 1];			// vector = array. z = near z value. w = 1.
	
	console.log ("before pm:");
	console.log (v);

	v = MatrixVectorMultiply (pm, v);

	console.log ("after pm:------vvvvv-----	");
	console.log (v);

		// divide by w.
	v[0] /= v[3];
	v[1] /= v[3];
	v[2] /= v[3];

	console.log ("after /w:::::");
	console.log (v);
	
		// multiply by screen size and offset.

//	console.log ("ox: " + ox + " v[0]:" + v[0] + " sw/2:" + (sw/2));
	v[0] = ox + (v[0] * (sw * 0.5));		// note.. /2 as range is [-1..1]
	v[1] = oy - (v[1] * (sh * 0.5));
	
	console.log ("screen : -------------------------------------");
	console.log (v);
	
		// ------------------ reverse it !! ---------------------

	console.log ("---------------- reverse process -----------------------!!!");


	v[0] = sw;
	v[1] = sh;
	v[2] = -1;		// z set to any value (doesn't matter!!)
	v[3] = 1;		// w is assumed to be 1 for now, so no need to do *w.

	console.log ("x:" + v[0] + " y:" + v[1]);
	
		// convert range to 0...1
	v[0] = v[0] / sw;
	v[1] = v[1] / sh;
	
	console.log ("range [0..1]");
	console.log (v);
	
		// scale to range -1 .. 1	
	v[0] = (v[0] * 2) - 1;
	v[1] = 1 - (v[1] * 2);
	
	console.log ("range [-1..1]");
	console.log (v);
	
	v = MatrixVectorMultiply (im, v);
	
//	v[0] *= v[3];
//	v[1] *= v[3];

	console.log ("after im:");
	console.log (v);
	
	v[0] /= v[3];
	v[1] /= v[3];
	v[2] /= v[3];

	console.log ("/= w:");
	console.log (v);
	


}

function DoStuff()
{
	DrawListTests();

	C3D_IsAvailable_WebGL();

//	C3D_Init ("glcvs", C3D_TYPE_WEBGL, NEAR_Z, FAR_Z);
	C3D_Init ("glcvs", C3D_TYPE_2D, NEAR_Z, FAR_Z);
	
	Cvs = document.getElementById ("cvs");
	Ctx = Cvs.getContext ("2d");
	
	Cvs.addEventListener("pointerdown", PointerDown, false);
	Cvs.addEventListener("pointermove", PointerMove, false);
	Cvs.addEventListener("pointerup", PointerUp, false);
	Cvs.addEventListener("pointercancel", PointerCancel, false);

	LoadModelData();
	
	InitCubes();
	
	InitCamera();
	
	LineTest();
	
//	DrawTest();
	
	requestAnimationFrame (AnimLoop);

//	CubeTest();

//	InverseMatrixTest();

}

</script>
</head>
<body onload="DoStuff();">
	<div class="overlay" id="overlay"> </div>
	<div class="container">
	<canvas class="glcvs" id="glcvs" width="768" height="768"></canvas>
 	<canvas class="cvs" id="cvs" width="512" height="512"></canvas>
	</div>
</body>
</html>
