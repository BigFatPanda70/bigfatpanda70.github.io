<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<html>
<head>
<meta name="google-site-verification" content="64yvLnoiyLMUpmBlNZ0o6SUOF84GCxrd2qdb2jqiZGA" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 

<link rel="stylesheet" href="styles.css">


</head>
<body>

<div id="wrap">
	<div id="main">
		<div class="navbar">
			<div class="navitem"><a class="navlink" href="https://bigfatpanda70.github.io"><img src="./../images/panda_small.png" alt="small logo image"></a></div>
		</div>

		<div class="row">
		<div class="left">
			&nbsp;
			<div class="vmenu">
				<a href="games">My Games</a>
				<a href="tech stuff">Tech stuff</a>
			</div>
		</div>

		<div class="main">
			<h2> Javascript Frame Counter:</h2>
			<p> </p>
			<p> Back in the days of DOS and terminal based software, it wasn't uncommon to see main loops such as the following pseudocode:<br>
			<br>
			<code>
				i = 0;<br>
				while (i != 1)<br>
				{<br>
					&nbsp&nbsp&nbsp&nbsp read the keyboard.<br>
					&nbsp&nbsp&nbsp&nbsp do some processing<br>
					&nbsp&nbsp&nbsp&nbsp while (screen refresh signal not ready) *do nothing*<br>
					&nbsp&nbsp&nbsp&nbsp if exit required, i = 1<br>
				}<br>
				</code>
			<br>
			<p> Each game updated at around the same refresh rate as the screen. As long as you could keep all your processing within the time it would take to draw a screen you would have a smooth and fast piece of software. There is nothing wrong with the above loop, if you can assume yours is the only piece of software running. Home computers of the 80's typically did not have any other timing clocks to work with, so this kind of thing was used everywhere.</p>
			
			<p> A possible improvement on the above loop, would be to substitute a wait() or sleep() call in place of the while loop.</p>
			<code>
				i = 0;<br>
				while (i != 1)<br>
				{<br>
					&nbsp&nbsp&nbsp&nbsp read the keyboard.<br>
					&nbsp&nbsp&nbsp&nbsp do some processing<br>
					&nbsp&nbsp&nbsp&nbsp wait(for some event);<br>
					&nbsp&nbsp&nbsp&nbsp if exit required, i = 1<br>
				}<br>
				</code>
			<br>
			<p> Calls like wait(), sleep() pause() are usually system calls, which suspend your program and go and do something else before returning.</p>
			<p> The downside to this kind of control loop is that it's not very flexible, it tends to be put in place for very specific purposes and programmers would tend to put these loops all over their code. The most common one I can think of is adding this kind of loop every time you wanted the user to press a key. </p>
			<p> Then along came the next generation of operating systems, which also had a main processing loop, but was structured somewhat differently so that the operating system could get some other tasks done as well. Instead of hogging the cpu, messages or events are used to control the flow of a program.</p>
	
			<br>
				<code>
				i = 0;<br>
				while (CheckMessage() != done)<br>
				{<br>
					&nbsp&nbsp&nbsp&nbspGetMessage()<br>
					&nbsp&nbsp&nbsp&nbspProcessMessage()<br>
				}<br>
				</code><br>
				CheckMessage, or its equivalent, would yield control to the operating system and only really get back to your application when it could be bothered.
			<br>
			<p> Fast forward to the modern browser based systems and   </p>
			<br>
			<br>
			<br>
			<br>
			<br>
			- Nick.
		</div>  <!-- class main -->

		<div class="right">
			<div class="rightbox"><u>Unchecked facts:</u><br>Cows moo with regional accents.</div>
		</div>


	</div>
	<div id="info"></div>

	</div> <!-- main -->
</div>	<!-- wrap -->


<div id="footer">
	<div id="footercell">
		<p>Website by Nick Fleming : Last updated 2020/03/10 <a href="cookie.html">Cookies</a>&nbsp<a href="privacy.html">Privacy</a></p>
	</div>
</div>

</body>
</html>
