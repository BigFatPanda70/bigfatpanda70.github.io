<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!--

Title	:	Self contained game .

Info	:	Version 0.0	10th March 2020

Author	:	Nick Fleming

Updated	:	25th March 2020

 11th March :
----------------
	Adding small 3D engine, with draw list. Nothing fancy, just
something that works.
	DrawList code added - uses basic hash algorithm to sort the
	triangles into z order. This is the biggest bottleneck of all,
	especially for large objects.

	z order drawing is completely reversed ! (don't know why!), something to do with the opengl matrix spec i think.

 12th March 2020
-----------------
	Adding camera matrix, fixing issues with z direction for draw buffer.

 13th March 2020
-----------------
	Been Coronovirus shopping.. the world has gone mad.

	ok.. supplies are in.. got work to do.

 14th March 2020
-------------------
	OpenGl projection matrix is the mirror image of one where the z goes into the screen .
	So ..
		backface cull check has to be reversed.
		Check -x is to the left and +y is towards the top of the screen (use either oy +y or oy-y accordingly).


 16th March 2020
------------------
	Doing camera tests still.. this is HARD to get right.

	.. think I've finally got it working !!

	The order that the camera rotation matrix is mulitiplied with the
	camera translation matrix makes a great deal of difference.
	The camera rotations will not work otherwise.

	Example.

	camera pos {2,0,3}
	look at {0,0,0}

	(column major matrix used)

	camera rotate & translate matrix should be:
	{
		0.832	0   -0.554    0
		0       1    0        0
		0.554   0    0.832    -3.605
		0       0    0        1
	}

	if the wrong order is used, the -3.605 value will be wrong.

	 20th March 2020
	-----------------
		Coronovirus panic buying in full swing.. supermarkets cannot
	get supplies in fast enough.. the world has gone mad.

	Trying to get isosphere object working.. for some reason it won't
	display


	 21st March 2020
	------------------
		Ambient Lighting calculations:

	ambient_amount = [0..1]
	light_colour = [0..1]
	object_colour = [0..1]

	ambient = ambient_amount * light_colour;

	colour = ambient * object_colour;

	 22nd march 2020
	------------------
		calculations for diffuse light appear to be working ok.
	rejigging the normal calculations so i can have dynamic lighting
	(hopefully).
	
	 24th March 2020
	------------------
	experimenting with layouts.
	
	 25th March 2020
	--------------------
		This is probably more complicated than it needs to be,
	but I'm trying to keep the game engine separate from the
	rendering engine.
-->

<html>
<head>
<style>

body
{
	background-color:white;
}

.outer
{
	height:100%;
	background-color:black;
	text-align:center;
}

/*.container
{
	width:50%;
	height:100%;
	background-color:red;
	margin: 0 auto;
}
*/

.frame_counter
{
	position:absolute;
	left:0;
	top:0;
	background-color:#fff;
	z-index:1;
}

.gamecanvas
	{
		cursor:none;
		margin:0;
		padding:0;
		overflow: hidden;
		display:block;
		background-color:#000000;
		width:100%;					/* width = container width */
		height:100%;				/* height = container height */
}

.left
{
	float:left;
	height:100%;
	width:20%;
	background-color:#eeccaa;
}

.right
{
	float:left;
	height:100%;
	height:100%;
	width:20%;
	background-color:#bbddff;
}

.topcornerimage
{
	position:absolute;
	left:10px;
	top:10px;
	z-index:1;
}

.joystickdiv
{
	position:absolute;
	left:20px;
	top:50px;
	background-color:white;
}

</style>

<script src="js/frame_counter.js"></script>
<script src="js/matrix.js"></script>
<script src="js/vector.js"></script>
<script src="js/camera.js"></script>
<script src="js/joystick.js"></script>
<script src="js/inkeys.js"></script>
<script src="js/icosphere.js"></script>
<script src="js/collisions.js"></script>
<script src="js/batnball.js"></script>

<script>

var OBJECT_OFF = 0;
var OBJECT_ON = 1;

var WALL_WIDTH = 0.5;

var BRICK_WIDTH = 1.5;
var BRICK_HEIGHT = 1.8;

var NUM_BRICK_ROWS = 5;
var NUM_BRICK_COLUMNS = 10;
var BAT_WIDTH = BNB_BAT_WIDTH;
var BAT_HEIGHT= BNB_BAT_HEIGHT;
var once = 0;

var DRAWLIST_INVALID_IDX = -1;
var DRAWLIST_MAXBUCKETS = 512;

var near_z = 1.0;
var far_z = 1000;

var Canvas;
var Ctx;


//var BallX = 0;
//var BallY = -4;
//var BallZ = -10;	// constant.
//var BallIncX = -0.1;
//var BallIncY = 0.1;

var BallObjectId;
var BatObjectId;

var BallRotateX;
var BallRotateY;


var TopWallY = 19.5;
var LeftWallX = -9.4;
var RightWallX = 9.4;

var TestMap =
[
	0,1,1,1,1,1,1,1,1,0,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	0,1,1,0,1,1,0,1,1,0
];

var colours =
[
	"#000000",
	"#000088",
	"#008800",
	"#008888",
	"#880000",
	"#880088",
	"#888800",
	"#888888",

	"#aaaaaa",
	"#0000ff",
	"#00ff00",
	"#00ffff",
	"#ff0000",
	"#ff00ff",
	"#ffff00",
	"#ffffff"

];


	// the vertices for each cube face are stored separately
	// so each cube face can have different vertex colours/textures/fx.

var vertices =
[
	-1, 1,-1,		// front 4 vertices
	 1, 1,-1,
	 1,-1,-1,
	-1,-1,-1,

	 1, 1, 1,		// back vertices.,0,0,
	-1, 1, 1,
	-1,-1, 1,
	 1,-1, 1,

	-1, 1, 1,		// left faces
	-1, 1,-1,
	-1,-1,-1,
	-1,-1, 1,

	 1, 1,-1,		// right faces
	 1, 1, 1,
	 1,-1, 1,
	 1,-1,-1,

	-1, 1, 1,		// top faces
	 1, 1, 1,
	 1, 1,-1,
	-1, 1,-1,

	// bottom faces
	-1,-1,-1,
	 1,-1,-1,
	 1,-1, 1,
	-1,-1, 1
];


var faces =
[
	0,1,2,
	2,3,0,

	4,5,6,
	6,7,4,

	9,10,8,
	10,11,8,

	12,13,14,
	12,14,15,

	16,17,18,
	16,18,19,

	20,21,22,
	23,20,22
];

/*var WallVertices = 
[
	-1,  1, -1,
	 1,  1, -1,
	 1, -1, -1,
	-1, -1, -1,
	
	 1,  1,  1,
	-1,  1,  1,
	-1, -1,  1,
	 1, -1,  1
];

var WallFaces = 
[
	0,1,2,		// front
	2,3,0,

	4,5,6,		// back
	6,7,4,
	
	5,0,3,		// left
	3,6,5,
	
	1,4,7,		// right
	7,2,1,
	
	5,4,1,		// top
	1,0,5,
	
	3,2,7,		// bottom
	7,6,3
];
*/

var ProjectionMatrix;
var Camera;
var CameraAngle = 0;
var cam_dist = 20;
var EnableCamera = true;

var TestObjects = [];
var TestModel;
var TestModel2;

var WallModel;
var TopWallModel;
var BatModel;
var BallModel;
var BrickModel;

var BackfaceCullEnabled = true;

function _BackfaceCullCheck (x0,y0,x1,y1,x2,y2)
{
	// this can determine whether a triangle is front or back facing.
	// pinched from https://cboard.cprogramming.com/game-programming/1057-backface-culling-lesson10-nehegl-tutorials.html

	var z=((x1-x0)*(y2-y0)) - ((y1-y0)*(x2-x0));
	return z;
}

	// --------------------------------------------
	//		Drawing order / Drawlist stuff
	// --------------------------------------------

var DrawList = [];
var DrawList_BucketArray = [];
var DrawList_FreeItem;				// used to recycle drawlist items.

function DrawListItem()
{
	this.object_index;
	this.previous_idx;
	this.next_idx;
	this.zindex;

		// draw list 2D triangle
	this.rgbhex;
	this.x0;
	this.y0;
	this.x1;
	this.y1;
	this.x2;
	this.y2;
}

function ClearDrawList()
{
	var i;

	for (i = 0; i < DRAWLIST_MAXBUCKETS; i++)
	{
		DrawList_BucketArray[i] = DRAWLIST_INVALID_IDX;
	}
	DrawList_FreeItem = 0;	// reuse draw list, don't  waste memory.
}


function DrawList_AddItem (object_index, object_z, x0,y0,x1,y1,x2,y2, rgbhex)
{
	var b;		// bucket hash value (0 to MAXBUCKETS)
	var i;
	var idx;		// index of new drawlist item

	// object_z should be directed into the screen (so bigger z = further away.)

//	if ((object_z < near_z) || (object_z >= far_z))
//	{
//		return;
//	}

//	console.log ("object z" + object_z);

	b= ((object_z - near_z) * DRAWLIST_MAXBUCKETS) / (far_z - near_z);
	b = Math.floor(b);

	if ((b < 0) || (b >= DRAWLIST_MAXBUCKETS))
	{
			// reject any objects that can't be viewed.
		return;
	}

		// create drawlist item.
	idx = DrawList_FreeItem++;
	if (idx == DrawList.length)
	{
		DrawList[idx] = new DrawListItem();
	}
	DrawList[idx].object_index = object_index;
	DrawList[idx].zindex = object_z;
	DrawList[idx].previous_idx = DRAWLIST_INVALID_IDX;
	DrawList[idx].next_idx = DRAWLIST_INVALID_IDX;

	DrawList[idx].x0 = x0;
	DrawList[idx].y0 = y0;
	DrawList[idx].x1 = x1;
	DrawList[idx].y1 = y1;
	DrawList[idx].x2 = x2;
	DrawList[idx].y2 = y2;
	DrawList[idx].rgbhex = rgbhex;

	if (DrawList_BucketArray[b] == DRAWLIST_INVALID_IDX)
	{
			// empty bucket.. add new item to bucket
		DrawList_BucketArray[b] = idx;
		return;
	}

	// bucket is used, so need to insert sort into this z list.
	// z values are sorted largest first to smallest (i.e. in required drawing order)

	i = DrawList_BucketArray[b];		// get draw list index of first item in z list

	if ((i < 0) || (i >= DrawList.length))
	{
		console.log ("first i out of range");
		return;
	}

	// this is the bottle neck for large numbers of items with a similar z value.

	while (object_z < DrawList[i].zindex)
	{
		if (DrawList[i].next_idx == DRAWLIST_INVALID_IDX)
		{
			// reached the end of the list, so just add item.
			DrawList[i].next_idx = idx;
			DrawList[idx].previous_idx = i;
			DrawList[idx].next_idx = DRAWLIST_INVALID_IDX;
			return;
		}
		i = DrawList[i].next_idx;
		if ((i < 0) || (i >= DrawList.length))
		{
//			console.log ("i out of range");		// error checking.
		}
	}

	// z >= current item, so insert before it.
	DrawList[idx].previous_idx = DrawList[i].previous_idx;
	DrawList[idx].next_idx = i;

	DrawList[i].previous_idx = idx;

	if (DrawList[idx].previous_idx == DRAWLIST_INVALID_IDX)
	{
		// new item is at start of list, so update bucket list.
		DrawList_BucketArray[b] = idx;
	}
	else
	{
		// update previous z item
		DrawList[DrawList[idx].previous_idx].next_idx = idx;
	}
}

function Draw_DrawList()
{
	var b;
	var i;
	var d;

	for (b = DrawList_BucketArray.length-1; b >= 0; b--)
//	for (b = 0; b < DrawList_BucketArray.length; b++)
	{
		if (DrawList_BucketArray[b] != DRAWLIST_INVALID_IDX)
		{
			i = DrawList_BucketArray[b];
//			console.log ("i" + i);
			while (i != DRAWLIST_INVALID_IDX)
			{
				d = DrawList[i];
				Ctx.beginPath();
				Ctx.fillStyle = d.rgbhex;
				Ctx.strokeStyle = d.rgbhex;
				Ctx.moveTo (d.x0, d.y0);
				Ctx.lineTo (d.x1, d.y1);
				Ctx.lineTo (d.x2+0.5, d.y2);
				Ctx.lineTo (d.x0, d.y0);
				Ctx.fill();
				Ctx.stroke();
				i = d.next_idx;
			}
		}
	}
}

	// -------------- end of draw list stuff -----------------

function NormalVector (x,y,z)
{
	this.x = x;
	this.y = y;
	this.z = z;
}

NormalVector.prototype.normalise = function()
{
	var d;

	d = Math.sqrt((this.x*this.x) + (this.y*this.y)+(this.z*this.z));
	if (d != 0)
	{
		this.x /= d;
		this.y /= d;
		this.z /= d;
	}
}

                            
function Model3D (vertex_array, face_array)
{
		// creates a 3D model from vertex and face data.

	var i;
	var lp;

	this.initial_verts =[];
	this.vertices =[];						// current (transformed) vertices
	this.faces =[];
	this.initial_normal = [];
	this.normal = [];

	this.ia = 0.4;			// intensity of ambient light level

	this.red = 1.0;			// default object colour.
	this.green = 0.0;
	this.blue = 0.0;

	this.r = [];		// per face colours
	this.g = [];
	this.b = [];

	i = 0;
	for (lp = 0; lp < vertex_array.length; lp += 3)
	{
		this.initial_verts[i++] = vertex_array[lp];		// x
		this.initial_verts[i++] = vertex_array[lp+1];	// y
		this.initial_verts[i++] = vertex_array[lp+2];	// z
		this.initial_verts[i++] = 1;							// w should be 1
	}

	for (lp = 0; lp < face_array.length; lp++)
	{
		this.faces[lp] = face_array[lp];
	}

	i = 0;
	for (lp = 0; lp < face_array.length; lp += 3)
	{
		this.r[i] = this.ia;
		this.g[i] = this.ia;
		this.b[i] = this.ia;
		i++;
	}

//	console.log (this.initial_verts);
//	console.log ("num v:" + this.initial_verts.length);
//	console.log ("num f:" + this.faces.length);
}

Model3D.prototype.initNormals = function()
{
	// calculates the normals for each face.
	// should only have to do this once, hopefully.

	// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
	// newells method ???

//	console.log ("init normals");

	var i;
	var lp;

	var v0;
	var v1;
	var v2;
	
	var x0;
	var y0;
	var z0;
	var x1;
	var y1;
	var z1;
	var x2;
	var y2;
	var z2;

	var ux;
	var uy;
	var uz;

	var vx;
	var vy;
	var vz;

	var nx;
	var ny;
	var nz;
	var d;
	
	var w;

//	if (once == 0)
//	{
//		console.log (this.initial_verts);
//	}

	w = 1;		// 4th value for normal vector
	i = 0;
	for (lp = 0; lp < this.faces.length; lp += 3)
	{
		v0 = this.faces[lp+0] * 4;
		v1 = this.faces[lp+1] * 4;
		v2 = this.faces[lp+2] * 4;
		
		x0 = this.initial_verts[v0+0];
		y0 = this.initial_verts[v0+1];
		z0 = this.initial_verts[v0+2];

		x1 = this.initial_verts[v1+0];
		y1 = this.initial_verts[v1+1];
		z1 = this.initial_verts[v1+2];

		x2 = this.initial_verts[v2+0];
		y2 = this.initial_verts[v2+1];
		z2 = this.initial_verts[v2+2];
		
//		if (once == 0)
//		{
//			console.log ("i:" + i + " v0:" + v0 + " x0:" + x0 + " y0:" + y0 + " z0:" + z0);
//			console.log ("i:" + i + " v1:" + v1 + " x1:" + x1 + " y1:" + y1 + " z1:" + z1);
//			console.log ("i:" + i + " v2:" + v2 + " x2:" + x2 + " y2:" + y2 + " z2:" + z2);
//		}

			// U = p1 - p0
		ux = x1 - x0;	//this.initial_verts[v1+0] - this.initial_verts[v0+0];
		uy = y1 - y0;	//this.initial_verts[v1+1] - this.initial_verts[v0+1];
		uz = z1 - z0;	//this.initial_verts[v1+2] - this.initial_verts[v0+2];
		
//		if (once == 0)
//		{
//			console.log ("i:" + i + " ux:" + ux + " uy:" + uy + " uz:" + uz);
//		}


			// V = p2 = p0
		vx = x2 - x0;	//this.initial_verts[v2+0] - this.initial_verts[v0+0];
		vy = y2 - y0;	//this.initial_verts[v2+1] - this.initial_verts[v0+1];
		vz = z2 - z0;	//this.initial_verts[v2+2] - this.initial_verts[v0+2];

//		if (once == 0)
//		{
//			console.log ("i:" + i + " vx:" + vx + " vy:" + vy + " vz:" + vz);
//		}

			// normal is cross product of two edge  vectors N = U X V
		nx = (uy*vz)-(uz*vy);	// Nx = UyVz - UzVy
		ny = (uz*vx)-(ux*vz);	// Ny = UzVx - UxVz
		nz = (ux*vy)-(uy*vx);	// Nz = UxVy - UyVx

		d = Math.sqrt((nx*nx)+(ny*ny)+(nz*nz));
		if (d != 0)
		{
			nx /= d;
			ny /= d;
			nz /= d;
		}
		
		this.initial_normal[i++] = nx;
		this.initial_normal[i++] = ny;
		this.initial_normal[i++] = nz;
		this.initial_normal[i++] = w;
//		if (once == 0)
//		{
//			console.log ("i:" + i + " nx:" + nx);
//			console.log ("i:" + i + " ny:" + ny);
//			console.log ("i:" + i + " nz:" + nz);
//		}
	}
}

Model3D.prototype.rotateNormals = function (rx,ry,rz)
{
	// for now, just copies normal data over while testing.
	var m;
	var i;
	
	m = MatrixIdentity();
	m = MatrixRotate (m,rx,ry,rz);
	MatrixVectorArrayMultiply (m, this.initial_normal, this.normal);
}

Model3D.prototype.calcLighting = function (light_x, light_y, light_z)
{
	// calculates surface lighting using light vector (lx,ly,lz)

	//  light vector *MUST* be normalised.

	// lx = objectx - lightx;
	// ly = objecty - lighty;

	// L = unit vector to light
	// n = unit surface normal
	// k = diffuse intensity

	// cos_0 = I . n

	// Id

	var lx;
	var ly;
	var lz;
	var dl;

	var diffuse;
	var i;

	var nx;
	var ny;
	var nz;
	var w;
	var cos_a;
	
	var n;

	var k;

	var l;

	var r;
	var g;
	var b;

	lx = light_x;
	ly = light_y;
	lz = light_z;
	dl = Math.sqrt ((lx*lx) + (ly*ly) + (lz*lz));
	if (dl != 0)
	{
		lx /= dl;
		ly /= dl;
		lz /= dl;
	}

//	if (once == 0)
//	{
//		console.log ("lx:" + lx + " ly:" + ly + " lz:" + lz);
//		console.log (this.normal);
//	}

	k =0.5;		// k = diffuse intensity


	i = 0;
	for (n = 0; n < this.normal.length; n += 4)
	{
		nx = this.normal[n+0];
		ny = this.normal[n+1];
		nz = this.normal[n+2];
		w = this.normal[n+3];

		diffuse = k * ((nx * lx) + (ny * ly) + (nz * lz));

		if (diffuse < 0)	{	diffuse = 0; }
		if (diffuse > 1)	{ diffuse = 1;}


		l = diffuse + this.ia;	//ambient;
		if (l > 1)	l = 1;

		this.r[i] = l * this.red;
		this.g[i] = l * this.green;
		this.b[i] = l * this.blue ;
		i++;
	}
}

Model3D.prototype.transform = function (tx,ty,tz, rx,ry,rz, sx,sy,sz)
{
	var m;
	var n;

	m = MatrixIdentity();

		// do normal rotations
//	n = MatrixIdentity();
//	n = MatrixRotate (n,rx,ry,rz);
//	MatrixVectorArrayMultiply (m, this.initial_verts, this.vertices);

//	console.log ("identity ");
//	console.log (m);
	m = MatrixScale (m, sx,sy,sz);
	m = MatrixRotate (m, rx,ry,rz);
	m = MatrixTranslate (m, tx,ty,tz);
/*
	if (once == 0)
	{
		console.log ("before transform .....");
		console.log ("z0:" + this.vertices[2]);
		console.log ("z1:" + this.vertices[5]);
		console.log ("z2:" + this.vertices[8]);
		console.log ("z3:" + this.vertices[11]);
	}
*/
	if (EnableCamera == true)
	{
		m = MatrixMultiply (Camera.cam_matrix, m);
//		m = MatrixRotate (m, 0,90,0);

	}

	MatrixVectorArrayMultiply (m, this.initial_verts, this.vertices);

/*	if (once == 0)
	{
		console.log ("after transform .....");
		console.log ("z0:" + this.vertices[2]);
		console.log ("z1:" + this.vertices[6]);
		console.log ("z2:" + this.vertices[10]);
		console.log ("z3:" + this.vertices[14]);

		console.log ("z0:" + this.vertices[18]);
		console.log ("z1:" + this.vertices[22]);
		console.log ("z2:" + this.vertices[26]);
		console.log ("z3:" + this.vertices[30]);
	}
*/

//	console.log ("verts");
//	console.log (this.vertices);
}

function Object3D(ref_model_3d)
{
	this.state;		// OBJECT_ON or OBJECT_OFF
	this.flags;
	this.x = 0;
	this.y = 0;
	this.z = 0;
	this.rx = 0;
	this.ry = 0;
	this.rz = 0;
	this.sx = 1;
	this.sy = 1;
	this.sz = 1;
	this.red = 1;
	this.green = 1;
	this.blue = 1;
	this.model_ref = ref_model_3d;	// pointer to model data.

	this.left;
	this.right;
	this.top;
	this.bottom;
	this.near;
	this.far;

	this.vx = 0;
	this.vy = 0;
	this.vz = 0;
}

Object3D.prototype.move = function (tx,ty,tz)
{
	this.x += tx;
	this.y += ty;
	this.z += tz;
}

Object3D.prototype.aabb = function (dt)
{
	// calculate Axis Aligned Bounds Box from transformed points
	// for dt seconds. This area will cover not only the object,
	// but any space it moves through.

	var i;
	var x;
	var y;
	var z;

	if (this.model_ref.vertices.length < 1)
	{
		console.log ("no model defined");
		return;
	}

	x = this.model_ref.vertices[0];
	y = this.model_ref.vertices[1];
	z = this.model_ref.vertices[2];
	this.left = x;
	this.right = x;
	this.top = y;
	this.bottom = y;
	this.near = z;
	this.far = z;
	for (i = 0; i < this.model_ref.vertices.length; i += 4)
	{
		x = this.model_ref.vertices[i+0];
		y = this.model_ref.vertices[i+1];
		z = this.model_ref.vertices[i+2];
		if (x < this.left) this.left = x;
		if (x > this.right) this.right = x;
		if (y < this.top)	this.top = y;
		if (y > this.bottom)	this.bottom = y;
		if (z < this.near)	this.near = z;
		if (z > this.far)	this.far = z;

		x += this.vx * dt;
		y += this.vy * dt;
		z += this.vz * dt;

		if (x < this.left) this.left = x;
		if (x > this.right) this.right = x;
		if (y < this.top)	this.top = y;
		if (y > this.bottom)	this.bottom = y;
		if (z < this.near)	this.near = z;
		if (z > this.far)	this.far = z;
	}
}

function AABB3D_compare (a,b)
{
	// returns true if one is inside the other,
	// otherwise returns false.

	if (a.right < b.left)
	{
		// a is to the left of b
		return false;
	}
	if (a.left > b.right)
	{
		// b is to the left of a
		return false;
	}
	if (a.bottom < b.top)
	{
		return false;
	}
	if (a.top > b.bottom)
	{
		return false;
	}

	if (a.far < b.near)
	{
		return false;
	}
	if (a.near > b.far)
	{
		return false;
	}

	return true;
}

function CreateDrawList(object_array, first, last)
{
		// creates a draw list from an object array of Object3D structures.
		// first and last are used to only draw part of the draw list

	var i;
	var k;
	var w;
	var p;
	var m;

	var v0;
	var v1;
	var v2;

	var x0;
	var y0;
	var x1;
	var y1;
	var x2;
	var y2;
	var z0;
	var z1;
	var z2;
	var z;

	var ox;
	var oy;

	var halfwidth;
	var halfheight;

	var c;

	var backface_cull = false;

	var rgbhex;
	var r;
	var g;
	var b;

	halfwidth = Canvas.width >> 1;
	halfheight = Canvas.height >> 1;
	ox = halfwidth;
	oy = halfheight;

		// creates the draw list from the array of objects provided.
	ClearDrawList();

//	for (i = 0; i < object_array.length; i++)
	for (i = first; i < last; i++)
	{
		p = object_array[i];
		m = p.model_ref;
		m.red = p.red;
		m.green = p.green;
		m.blue = p.blue;
			// need to transform all the model points

		m.rotateNormals (p.rx, p.ry, p.rz);
		m.calcLighting  (0,0,400);
//	TestModel.calcLighting (500,300,400);	//light_x, light_y, light_z)

		m.transform
		(
			p.x, p.y, p.z,
			p.rx, p.ry, p.rz,
			p.sx, p.sy, p.sz
		);

			// do projection matrix.
		MatrixVectorArrayMultiply ( ProjectionMatrix, m.vertices, m.vertices);
//		MatrixVectorArrayMultiply ( m.vertices,ProjectionMatrix, m.vertices);

			// finally do divide by w
		for (k = 0; k < m.vertices.length; k += 4)
		{
			w = m.vertices[k+3];
			if (w != 0)
			{
				z = m.vertices[k+2];
				m.vertices[k+0] /= w;
				m.vertices[k+1] /= w;
//				m.vertices[k+2] /= w;	// DO NOT DIVIDE Z BY W.
			}
		}

			// convert to screen coords.

		c = 0;
		for (k = 0; k < m.faces.length; k += 3)
		{
			v0 = m.faces[k+0] * 4;
			v1 = m.faces[k+1] * 4;
			v2 = m.faces[k+2] * 4;

			x0 = ox + (halfwidth * m.vertices[v0]);
			y0 = oy - (halfheight* m.vertices[v0+1]);
			z0 = m.vertices[v0+2];

			x1 = ox + (halfwidth *m.vertices[v1]);
			y1 = oy - (halfheight*m.vertices[v1+1]);
			z1 = m.vertices[v1+2];

			x2 = ox + (halfwidth * m.vertices[v2]);
			y2 = oy - (halfheight *m.vertices[v2+1]);
			z2 = m.vertices[v2+2];

			z = (z0 + z1 + z2)/3;

/*			if (ytytyt == 0)
			{
				console.log ("k:" + k + " v0:" + v0 + " v1:" + v1 + " v2:" + v2);
				console.log ("x0:" + x0 + " y0:" + y0 + " z0:" + z0);
				console.log ("x1:" + x1 + " y1:" + y1 + " z1:" + z1);
				console.log ("x2:" + x2 + " y2:" + y2 + " z2:" + z2);
			}

//			if (once == 0) console.log ("k:" + k + "z:" + z + " z0 " + z0 + " z1 " + z1 + " z2 " + z2 + " ink:" + colours[c]);
*/
			backface_cull = false;
			if (BackfaceCullEnabled == true)
			{
				backface_cull = true;
				if (_BackfaceCullCheck (x0,y0,x1,y1,x2,y2) < 0)
				{
					backface_cull = false;
				}
			}

			if (backface_cull == false)
			{
//				z = z;		// convert z to draw list range.
				r = Math.floor (255 * m.r[c]);
				g = Math.floor (255 * m.g[c]);
				b = Math.floor (255 * m.b[c]);

				rgbhex = "rgb(" +  r + ","+ g + "," + b + ")";
				DrawList_AddItem (i, z, x0,y0,x1,y1,x2,y2, rgbhex);	//colours[c]);
			}
			c++;
		}
 	}
 	ytytyt = 1;
}

function PositionCamera()
{
	var r;

	var x;
	var y;
	var z;

	var cos_a;
	var sin_a;
	var a;

	r = 5.75;	//cam_dist;
	
	CameraAngle = 120;

	a = (CameraAngle * Math.PI)/180;
	cos_a = r * Math.cos (a);
	sin_a = r * Math.sin (a);

//	x = r * cos_a;
//	y = 10;
//	z = r * sin_a;

	x = 0;	
	y = r * cos_a;
	z = r * sin_a;

//	y = -80;
//	z = -70;

	CameraAngle += 1;
//	while (CameraAngle >= 360)
//	{
//		CameraAngle -= 360;
//	}

//	x = 0;
//	y = 6;
//	z = 44;

	Camera.setCamera (x,y,z, 0, 0, 0);
}

function OverheadView()
{
	var ox;
	var oy;
	var i;
	var c;

	var j;
	var x;
	var y;

	ox = Canvas.width >> 1;
	oy = Canvas.height >> 1;

	Ctx.beginPath();
	Ctx.fillStyle="#ffffff";
	Ctx.rect (ox , oy , 3,3);
	Ctx.fill();

	Ctx.beginPath();
	Ctx.fillStyle="#000000";
	Ctx.rect (ox + Camera.pos.x, oy + Camera.pos.z, 3,3);
	Ctx.fill();

	Ctx.beginPath();
	Ctx.strokeStyle="#ffff00";
	Ctx.moveTo (ox + Camera.pos.x, oy + Camera.pos.z);
	Ctx.lineTo (ox,oy);
	Ctx.stroke();

	c = 0;
	for (i = 0; i < TestObjects.length; i++)
	{
		Ctx.beginPath();
		Ctx.fillStyle = colours[c];
		Ctx.rect (ox + TestObjects[i].x, oy - TestObjects[i].z, 3,3);
		Ctx.fill();
		for (j = 0; j < TestObjects.length.vertices; j += 4)
		{
			Ctx.beginPath();
			x = TestObjects.length.vertices[j];
			z = TestObjects.length.vertices[j+3];

			Ctx.rect (ox+x, oy-y, 3,3);
			Ctx.fill();
		}
	}
}

function DrawGame()
{
	// uses data from batnball.js to draw the game.
	
	// Objects 0,1 & 2 are walls.. they do *not* change.
	
	// Object 3 is the bat - also always exists.
	
	// objects 4 and up are are created dynamically each frame so that
	// the number of balls/bricks can change as required.

	var i;
	var n;
	var first_dynamic_object;
	
	var first_brick;

	var rgb = 
	[
		0, 0, 0.9,
		0,0.7,0.7,
		0.8,0,0.5,
		1.0,0.5,0,
		1.0,0.7,0,
		1.0,1.2,0.1,
	];
	
	first_dynamic_object = 3;

	n = first_dynamic_object;

		// now turn all dynamic objects off.
	for (i = n; i < TestObjects.length; i++)
	{
		TestObjects[i].state = OBJECT_OFF;
	}

		// add player bats to the screen.
	for (i = 0; i < Player.length; i++)
	{
		if (n == TestObjects.length)
		{
			TestObjects[n] = new Object3D(BatModel);
		}
		TestObjects[n].state = OBJECT_ON;
		TestObjects[n].model_ref = BatModel;
		TestObjects[n].x = Player[i].x;
		TestObjects[n].y = Player[i].y;
		TestObjects[n].z = -10;
		TestObjects[n].red = 1;
		TestObjects[n].green = 1;
		TestObjects[n].blue = 0;
		n++;
	}


		// add any balls
	for (i = 0; i < Balls.length; i++)
	{
		if (Balls[i].state == BALL_ON)
		{
			if (n == TestObjects.length)
			{
				TestObjects[n] = new Object3D(BallModel);
			}
			TestObjects[n].state = OBJECT_ON;
			TestObjects[n].model_ref = BallModel;	// pointer to model data.

			TestObjects[n].x = Balls[i].x;
			TestObjects[n].y = Balls[i].y;
			TestObjects[n].z = -10;
			TestObjects[n].rx = BallRotateX;
			TestObjects[n].ry = BallRotateY;
			TestObjects[n].red = 1;
			TestObjects[n].green = 1;
			TestObjects[n].blue = 1;
			
			n++;
		}
	}

		// now add bricks.
//	first_brick = n;
	for (i = 0; i < Bricks.length; i++)
	{
		if (Bricks[i].state == BNB_BRICK_ON)
		{
			if (n == TestObjects.length)
			{
				TestObjects[n] = new Object3D(BrickModel);
			}
			TestObjects[n].state = OBJECT_ON;
			TestObjects[n].model_ref = BrickModel;	// pointer to model data.

			TestObjects[n].x = Bricks[i].x;
			TestObjects[n].y = Bricks[i].y;
			TestObjects[n].z = -10;
			
			TestObjects[n].red = rgb[0 + (Math.floor((i/12))*3)];
			TestObjects[n].green = rgb[1 + (Math.floor((i/12))*3)];
			TestObjects[n].blue = rgb[2 + (Math.floor((i/12))*3)];
			n++;
		}
	}
}


function DoInputs()
{
	var left_pressed;
	var right_pressed;
	var item;
	var i;
	var str;

	var up;
	var down;
	var left;
	var right;
	var l1;
	var r1;
	
	var lup;
	var ldown;
	var lleft;
	var lright;

	left_pressed = false;
	right_pressed = false;
	
	if ((KeyPressed (KEY_LEFT) == true) || 
		(KeyPressed (KEY_A) == true) ||
		(KeyPressed (KEY_J) == true))
	{
		left_pressed = true;
	}

	if ((KeyPressed (KEY_RIGHT) == true) ||
		(KeyPressed (KEY_D) == true) ||
		(KeyPressed (KEY_L) == true))
	{
		right_pressed = true;
	}

		// joystick tests too.

	Joystick_Update();
	if (Joystick_GetButton (0, JOYSTICK_LBC_LEFT) == true)
	{
		left_pressed = true;
	}
	if (Joystick_GetButton (0, JOYSTICK_LBC_RIGHT) == true)
	{
		right_pressed = true;
	}
	
	if (left_pressed)
	{
		BNB_LeftPressed(0);
	}
	if (right_pressed)
	{
		BNB_RightPressed(0);
	}

/*	item = document.getElementById ("Jstk");

	up =  Joystick_GetButton (0, JOYSTICK_RBC_TOP);
	down= Joystick_GetButton (0, JOYSTICK_RBC_BOTTOM);
	left= Joystick_GetButton (0, JOYSTICK_RBC_LEFT);
	right=Joystick_GetButton (0, JOYSTICK_RBC_RIGHT);

	lup =  Joystick_GetButton (0, JOYSTICK_LBC_TOP);
	ldown= Joystick_GetButton (0, JOYSTICK_LBC_BOTTOM);
	lleft= Joystick_GetButton (0, JOYSTICK_LBC_LEFT);
	lright=Joystick_GetButton (0, JOYSTICK_LBC_RIGHT);


	l1 = Joystick_GetButton (0, JOYSTICK_FB_TOP_LEFT);
	r1 = Joystick_GetButton (0, JOYSTICK_FB_TOP_RIGHT);
	str ="";
	
	str += "up:" + up + " down:" + down + " left:" + left + " right:" + right + "<br>";
	str += "lup:" + lup + " ldown:" + ldown + " lleft:" + lleft + " lright:" + lright + "<br>";
	str += "L1:" + l1 + " R1:" + r1 + "<br>";

	for (i = 0; i < Joystick_ButtonCount(0); i++)
	{
		str = str + i + ":" + Joystick_GetButton (0, i) + " ";
	}
	str += "<br>";
	for (i = 0; i < Joystick_AxisCount(0); i++)
	{
		str = str + i + ":" + Joystick_GetAxis (0, i) + " ";
	}

	item.innerHTML = str;
*/
}

var busy = false;
function UpdateGame()
{
	var dt;
	var i;
	if (busy == true)
	{
		return;
	}
	busy = true;
	requestAnimationFrame (UpdateGame);
	UpdateFrameCounter();

	if (!Ctx)	return;
	
	dt = 1/50;		// timing is 1/50th of a second.
	
	DoInputs();
	
	BNB_DoGame(dt);

	Ctx.clearRect(0,0,Canvas.width, Canvas.height);
	
	BallRotateX += 2.5;
	BallRotateY += 3.1;
	if (BallRotateX >= 360)
	{
		BallRotateX -= 360;
	}
	if (BallRotateY >= 360)
	{
		BallRotateY -= 360;
	}

/*
	TestObjects[BallObjectId].rx += 2.5;
	TestObjects[BallObjectId].ry += 3;
	if (TestObjects[BallObjectId].rx > 360)
	{
		TestObjects[BallObjectId].rx -= 360;
	}
	if (TestObjects[BallObjectId].ry > 360)
	{
		TestObjects[BallObjectId].ry -= 360;
	}
*/
	PositionCamera();

/*
	BallX += BallIncX;
	BallY += BallIncY;
	
	if (BallX <= (LeftWallX+WALL_WIDTH))
	{
		BallX = LeftWallX+WALL_WIDTH;
		BallIncX *= -1;
	}
	if (BallX >= (RightWallX-WALL_WIDTH))
	{
		BallX = RightWallX-WALL_WIDTH;
		BallIncX *= -1;
	}
	
	if (BallY >= TopWallY)
	{
		BallY = TopWallY;
		BallIncY *= -1;
	}

	TestObjects[BallObjectId].x = BallX;
	TestObjects[BallObjectId].y = BallY;
*/

	DrawGame();

		// draw static 'background' objects (i.e. walls)
	CreateDrawList(TestObjects,0,3);
	Draw_DrawList();

		// now draw everything else.
	CreateDrawList(TestObjects,3,TestObjects.length);
	Draw_DrawList();

//	CreateDrawList(TestObjects,3,65);
//	CreateDrawList(TestObjects,3,5);
//	Draw_DrawList();


//	OverheadView();


	busy = false;
	once = 1;
}

function FullSizeCanvas()
{
	// https://stackoverflow.com/questions/26745292/canvas-toggle-filling-whole-page-removing-scrollbar

	var w;
	var h;

	w = window.innerWidth;
	h = window.innerHeight;

	item = document.getElementById ("gc");
	item.style.width = w + "px";
	item.style.height = h + "px";
	
	document.body.scrollTop = 0; // <-- pull the page back up to the top
	document.body.style.overflow = 'hidden';

}

function MakeCuboid (width, height, depth, vertices, faces)
{
	var hh;
	var hw;
	var hd;
	
	hh = height/2;
	hw = width/2;
	hd = depth/2;
	
	vertices[0] = -hw; vertices[1] = hh; vertices[2] = -hd;
	vertices[3] =  hw; vertices[4] = hh; vertices[5] = -hd;
	vertices[6] =  hw; vertices[7] =-hh; vertices[8] = -hd;
	vertices[9] = -hw; vertices[10] =-hh; vertices[11] = -hd;

	vertices[12] =  hw; vertices[13] = hh; vertices[14] = hd;
	vertices[15] = -hw; vertices[16] = hh; vertices[17] = hd;
	vertices[18] = -hw; vertices[19] =-hh; vertices[20] = hd;
	vertices[21] =  hw; vertices[22] =-hh; vertices[23] = hd;

	faces[0] = 0; faces[1] = 1; faces[2] = 2;	// front
	faces[3] = 2; faces[4] = 3; faces[5] = 0;
	
	faces[6] = 4; faces[7] = 5; faces[8] = 6;
	faces[9] = 6; faces[10]= 7; faces[11]= 4;

	faces[12]= 5; faces[13]= 0; faces[14]=3;
	faces[15]= 3; faces[16]= 6; faces[17]=5;
	
	faces[18]= 1; faces[19]= 4; faces[20]=7;
	faces[21]= 7; faces[22]= 2; faces[23]=1;
	
	faces[24]= 5; faces[25]= 4; faces[26]=1;
	faces[27]= 1; faces[28]= 0; faces[29]=5;
	
	faces[30]= 3; faces[31]= 2; faces[32]=7;
	faces[33]= 7; faces[34]= 6; faces[35]=3;
}

function MakeModels()
{
		// creates 3D models from vertices for
		// walls, bat n ball.
	var i;
	var sy;
	var half_wall_length;
	var ww;
	
	var vertices = [];
	var faces = [];
	
	MakeCuboid (WALL_WIDTH, 24, 2.5, vertices, faces);
	WallModel = new Model3D (vertices, faces);
	WallModel.initNormals();

		// do top wall length based on side wall positions.

	MakeCuboid (20, 0.5, 2.5, vertices, faces);
	TopWallModel = new Model3D (vertices, faces);
	TopWallModel.initNormals();

	MakeCuboid (BAT_WIDTH, BAT_HEIGHT, 2.5, vertices, faces);
	BatModel = new Model3D (vertices, faces);
	BatModel.initNormals();

	vertices = [];
	faces = [];
	CreateIcosahedron (vertices, faces);
	for (i = 0; i < vertices.length; i++)
	{
		vertices[i] *= 0.25;
	}
	BallModel = new Model3D (vertices, faces);
	BallModel.initNormals();

	vertices = [];
	faces = [];
	MakeCuboid (BRICK_WIDTH, BRICK_HEIGHT, 3, vertices, faces);
	BrickModel = new Model3D (vertices, faces);
	BrickModel.initNormals();
}

function Init_3D_Objects()
{
	var x;
	var y;
	var i;
	var ox;
/*	
	var rgb = 
	[
		0, 0, 0.9,
		0,0.7,0.7,
		0.8,0,0.5,
		1.0,0.5,0,
		1.0,0.7,0,
		1.0,1.2,0.1,
	];
*/
	
	i = 0;
	TestObjects[i] = new Object3D(WallModel);
	TestObjects[i].state = OBJECT_ON;
	TestObjects[i].x = LeftWallX;	//left_wall_x;
	TestObjects[i].y = 7;
	TestObjects[i].z = -10;
	TestObjects[i].red = 0.5;
	TestObjects[i].green = 0.5;
	TestObjects[i].blue = 0.9;
	i++;

	TestObjects[i] = new Object3D(WallModel);
	TestObjects[i].state = OBJECT_ON;
	TestObjects[i].x = RightWallX;
	TestObjects[i].y = 7;
	TestObjects[i].z = -10;
	TestObjects[i].red = 0.5;
	TestObjects[i].green = 0.5;
	TestObjects[i].blue = 0.9;
	i++;

	TestObjects[i] = new Object3D(TopWallModel);
	TestObjects[i].state = OBJECT_ON;
	TestObjects[i].x = 0;
	TestObjects[i].y = 19.5;
	TestObjects[i].z = -10;
	TestObjects[i].red = 0.0;
	TestObjects[i].green = 1;
	TestObjects[i].blue = 1;
	i++;

/*
	BatObjectId = i;
	TestObjects[i] = new Object3D(BatModel);
	TestObjects[i].state = OBJECT_ON;
	TestObjects[i].x = 0;
	TestObjects[i].y = -5;
	TestObjects[i].z = -10;
	TestObjects[i].red = 1;
	TestObjects[i].green = 0.5;
	TestObjects[i].blue = 0;
	i++;

	BallObjectId = i;
	TestObjects[i] = new Object3D(BallModel);
	TestObjects[i].state = OBJECT_ON;
	TestObjects[i].x = 0;
	TestObjects[i].y = -3;
	TestObjects[i].z = -10;
	TestObjects[i].red = 0.95;
	TestObjects[i].green = 0.9;
	TestObjects[i].blue = 0.8;
	i++;
*/	
	
	
	
/*
	ox = -(11 * BRICK_WIDTH) /2;
	for (y = 0; y < 6; y++)
	{
		for (x = 0; x < 12; x++)
		{
			TestObjects[i] = new Object3D(BrickModel);
			TestObjects[i].x = ox + (x * BRICK_WIDTH);
			TestObjects[i].y = 4 + (y * BRICK_HEIGHT);
			TestObjects[i].z = -10;
			TestObjects[i].red = rgb[y*3];			//)(y/5);
			TestObjects[i].green = rgb[1+(y*3)];	//(y/5);
			TestObjects[i].blue = rgb[2+(y*3)];		//0.8;
			i++;
		}
	}
*/
}

function file_load_callback (txt_file)
{
	console.log ("loaded");
	document.write (txt_file);
}

function DoInits()
{
	var w;
	var h;
	var i;
	var m;

	Canvas = document.getElementById("gc");
	Ctx = Canvas.getContext("2d");

	if (Joystick_Available() == true)
	{
		console.log ("joystick is available");
		Joystick_ListenForConnect();
	}

	MatrixTest();

	FullSizeCanvas();

	w = Canvas.width;
	h = Canvas.height;
	ProjectionMatrix = Matrix_CreatePerspectiveProjectionMatrix
			(	w, h,
				30,			// field_of_view,
				near_z,		// z_near,
				far_z		// z_far
			);

	if (EnableCamera == true)
	{
		Camera = new Cam3D(
							0,10,20,
							0,1,0,
							0,0,0);

	}

	MakeModels();
	Init_3D_Objects();

	BNB_Init();
	
	console.log ("bricks");
	console.log (Bricks);

	BallRotateX = 0;
	BallRotateY = 0;

//	ClearDrawList();
//	CreateDrawList(TestObjects);
//	Draw_DrawList();

	once = 1;

	UpdateGame();
}

</script>


</head>
<body onload ="DoInits();">
<!--<div class="outer" id="area"> -->
<canvas class="gamecanvas" id="gc" width="512;" height="512;"></canvas>
<br>
<!-- </div> -->
<p class="frame_counter" id="fps">X</p>
<div class="joystickdiv" id="Jstk">joystick</div>
</body>
</html>
