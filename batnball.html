<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 

<!--

Title	:	Self contained game .

Info	:	Version 0.0	10th March 2020

Author	:	Nick Fleming

Updated	:	12th March 2020

 11th March :
----------------
	Adding small 3D engine, with draw list. Nothing fancy, just
something that works.
	DrawList code added - uses basic hash algorithm to sort the
	triangles into z order. This is the biggest bottleneck of all,
	especially for large objects.

	z order drawing is completely reversed ! (don't know why!), something to do with the opengl matrix spec i think.

 12th March 2020
-----------------
	Adding camera matrix, fixing issues with z direction for draw buffer.

 13th March 2020
-----------------
	Been Coronovirus shopping.. the world has gone mad.

	ok.. supplies are in.. got work to do.
-->

<html>
<head>
<style>

body 
{
	background-color:white;
}

.outer
{
	width:100%;
	height:100%;
	background-color:black;
	text-align:center;
}
.container
{
	width:50%;
	height:100%;
	background-color:red;
	margin: 0 auto;
}

.gamecanvas
{
	background-color:#ffccee;
	width:100%;					/* width = container width */
	height:100%;				/* height = container height */
}

.left
{
	float:left;
	height:100%;
	width:20%;
	background-color:#eeccaa;
}
.right
{
	float:left;
	height:100%;
	width:20%;
	background-color:#bbddff;
}

.topcornerimage
{
	position:absolute;
	left:10px;
	top:10px;
	z-index:1;
}


</style>

<script src="frame_counter.js"></script>
<script src="matrix.js"></script>
<script src="vector.js"></script>
<script src="camera.js"></script>

<script>
	
var once = 0;
	
var DRAWLIST_INVALID_IDX = -1;
var DRAWLIST_MAXBUCKETS = 512;

var near_z = 1.0;
var far_z = 1000;

var Canvas;
var Ctx;

var TestMap =
[
	0,1,1,1,1,1,1,1,1,0,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	0,1,1,0,1,1,0,1,1,0
]

var colours =
[
	"#000000",
	"#0000ff",
	"#00ff00",
	"#00ffff",
	"#ff0000",
	"#ff00ff",
	"#ffff00",
	"#ffffff"
];

	// the vertices for each cube face are stored separately
	// so each cube face can have different vertex colours/textures/fx.

var vertices =
[
	-1, 1,-1,		// front 4 vertices
	 1, 1,-1,
	 1,-1,-1,
	-1,-1,-1,

	 1, 1, 1,		// back vertices.,0,0,
	-1, 1, 1,
	-1,-1, 1,
	 1,-1, 1,

	-1, 1, 1,		// left faces
	-1, 1,-1,
	-1,-1,-1,
	-1,-1, 1,
	
	 1, 1,-1,		// right faces
	 1, 1, 1,
	 1,-1, 1,
	 1,-1,-1,
	
	-1, 1, 1,		// top faces
	 1, 1, 1,
	 1, 1,-1,
	-1, 1,-1,
	
	// bottom faces
	-1,-1,-1,
	 1,-1,-1,
	 1,-1, 1,
	-1,-1, 1
];

var faces =
[
	0,1,2,
	2,3,0,

	4,5,6,
	6,7,4,

	/*
	9,10,8,
	10,11,8,
	
	12,13,14,
	12,14,15,
	
	16,17,18,
	16,18,19,
	
	20,21,22,
	23,20,22
*/
];

var ProjectionMatrix;
var Camera;
var CameraAngle = 0;
var cam_dist = 40;

var TestObjects = [];
var TestModel;

var BackfaceCullEnabled = false;

function _BackfaceCullCheck (x0,y0,x1,y1,x2,y2)
{
	// this can determine whether a triangle is front or back facing.
	// pinched from https://cboard.cprogramming.com/game-programming/1057-backface-culling-lesson10-nehegl-tutorials.html

	if (BackfaceCullEnabled == false)
	{
		return 1;
	}
	var z=((x1-x0)*(y2-y0)) - ((y1-y0)*(x2-x0));
	return z; 
}

	// --------------------------------------------
	//		Drawing order / Drawlist stuff
	// --------------------------------------------

var DrawList = [];
var DrawList_BucketArray = [];
var DrawList_FreeItem;				// used to recycle drawlist items.

function DrawListItem()
{
	this.object_index;
	this.previous_idx;
	this.next_idx;
	this.zindex;
	
		// draw list 2D triangle
	this.rgbhex;
	this.x0;
	this.y0;
	this.x1;
	this.y1;
	this.x2;
	this.y2;
}

function ClearDrawList()
{
	var i;
	
	for (i = 0; i < DRAWLIST_MAXBUCKETS; i++)
	{
		DrawList_BucketArray[i] = DRAWLIST_INVALID_IDX;
	}
	DrawList_FreeItem = 0;	// reuse draw list, don't  waste memory.
}


function DrawList_AddItem (object_index, object_z, x0,y0,x1,y1,x2,y2, rgbhex)
{
	var b;		// bucket hash value (0 to MAXBUCKETS)
	var i;
	var idx;		// index of new drawlist item
	
	// object_z should be directed into the screen (so bigger z = further away.)

//	if ((object_z < near_z) || (object_z >= far_z))
//	{
//		return;
//	}

//	console.log ("object z" + object_z);
	
	b= ((object_z - near_z) * DRAWLIST_MAXBUCKETS) / (far_z - near_z);
	b = Math.floor(b);

	if ((b < 0) || (b >= DRAWLIST_MAXBUCKETS))
	{
		console.log ("b bad");
		return;		// should never get here.
	}

		// create drawlist item.
	idx = DrawList_FreeItem++;
	if (idx == DrawList.length)
	{
		DrawList[idx] = new DrawListItem();
	}
	DrawList[idx].object_index = object_index;
	DrawList[idx].zindex = object_z;
	DrawList[idx].previous_idx = DRAWLIST_INVALID_IDX;
	DrawList[idx].next_idx = DRAWLIST_INVALID_IDX;

	DrawList[idx].x0 = x0;
	DrawList[idx].y0 = y0;
	DrawList[idx].x1 = x1;
	DrawList[idx].y1 = y1;
	DrawList[idx].x2 = x2;
	DrawList[idx].y2 = y2;
	DrawList[idx].rgbhex = rgbhex;

	if (DrawList_BucketArray[b] == DRAWLIST_INVALID_IDX)
	{
			// empty bucket.. add new item to bucket
		DrawList_BucketArray[b] = idx;
		return;
	}

	// bucket is used, so need to insert sort into this z list.
	// z values are sorted largest first to smallest (i.e. in required drawing order)
	
	i = DrawList_BucketArray[b];		// get draw list index of first item in z list

	if ((i < 0) || (i >= DrawList.length))
	{
		console.log ("first i out of range");
		return;
	}

	// this is the bottle neck for large numbers of items with a similar z value.

	while (object_z < DrawList[i].zindex)
	{
		if (DrawList[i].next_idx == DRAWLIST_INVALID_IDX)
		{
			// reached the end of the list, so just add item.
			DrawList[i].next_idx = idx;
			DrawList[idx].previous_idx = i;
			DrawList[idx].next_idx = DRAWLIST_INVALID_IDX;
			return;
		}
		i = DrawList[i].next_idx;
		if ((i < 0) || (i >= DrawList.length))
		{
//			console.log ("i out of range");		// error checking.
		}
	}
	
	// z >= current item, so insert before it.
	DrawList[idx].previous_idx = DrawList[i].previous_idx;
	DrawList[idx].next_idx = i;

	DrawList[i].previous_idx = idx;

	if (DrawList[idx].previous_idx == DRAWLIST_INVALID_IDX)
	{
		// new item is at start of list, so update bucket list.
		DrawList_BucketArray[b] = idx;
	}
	else
	{
		// update previous z item
		DrawList[DrawList[idx].previous_idx].next_idx = idx;
	}
}

function Draw_DrawList()
{
	var b;
	var i;
	var d;
	
	for (b = DrawList_BucketArray.length-1; b >= 0; b--)	
//	for (b = 0; b < DrawList_BucketArray.length; b++)
	{
		if (DrawList_BucketArray[b] != DRAWLIST_INVALID_IDX)
		{
			i = DrawList_BucketArray[b];
//			console.log ("i" + i);
			while (i != DRAWLIST_INVALID_IDX)
			{
				d = DrawList[i];
				Ctx.beginPath();
				Ctx.fillStyle = d.rgbhex;
				Ctx.moveTo (d.x0, d.y0);
				Ctx.lineTo (d.x1, d.y1);
				Ctx.lineTo (d.x2, d.y2);
				Ctx.lineTo (d.x0, d.y0);
				Ctx.fill();
				i = d.next_idx;
			}
		}
	}
}

	// -------------- end of draw list stuff -----------------

function Model3D (vertex_array, face_array)
{
		// creates a 3D model from vertex and face data.

	var i;
	var lp;

	this.initial_verts =[];
	this.vertices =[];						// current (transformed) vertices 
	this.faces =[];

	i = 0;
	for (lp = 0; lp < vertex_array.length; lp += 3)
	{
		this.initial_verts[i++] = vertex_array[lp];		// x
		this.initial_verts[i++] = vertex_array[lp+1];	// y
		this.initial_verts[i++] = vertex_array[lp+2];	// z
		this.initial_verts[i++] = 1;							// w should be 1
	}
	
	for (lp = 0; lp < face_array.length; lp++)
	{
		this.faces[lp] = face_array[lp];
	}
}

Model3D.prototype.transform = function (tx,ty,tz, rx,ry,rz, sx,sy,sz)
{
	var m;
	
	m = MatrixIdentity();
	
//	console.log ("identity ");
//	console.log (m);
	m = MatrixScale (m, sx,sy,sz);
	m = MatrixRotate (m, rx,ry,rz);
	m = MatrixTranslate (m, tx,ty,tz);
	
	//m = MatrixMultiply (Camera.cam_matrix, m);
	
	MatrixVectorArrayMultiply (m, this.initial_verts, this.vertices);
	
//	console.log ("verts");
//	console.log (this.vertices);
}

function Object3D(ref_model_3d)
{
	this.x = 0;
	this.y = 0;
	this.z = 0;
	this.rx = 0;
	this.ry = 0;
	this.rz = 0;
	this.sx = 1;
	this.sy = 1;
	this.sz = 1;
	this.model_ref = ref_model_3d;	// pointer to model data.
}

Object3D.prototype.move = function (tx,ty,tz)
{
	this.x += tx;
	this.y += ty;
	this.z += tz;
}

function CreateDrawList(object_array)
{
		// creates a draw list from an object array of Object3D structures.

	var i;
	var k;
	var w;
	var p;
	var m;
	
	var v0;
	var v1;
	var v2;
	
	var x0;
	var y0;
	var x1;
	var y1;
	var x2;
	var y2;
	var z0;
	var z1;
	var z2;
	var z;
	
	var ox;
	var oy;
	
	var halfwidth;
	var halfheight;
	
	var c;
	
	halfwidth = 192;
	halfheight = 192;
	ox = halfwidth;
	oy = halfheight;
	
		// creates the draw list from the array of objects provided.
	ClearDrawList();

	for (i = 0; i < object_array.length; i++)
	{
		if (once == 0)	console.log ("object " + i);
		p = object_array[i];
		m = p.model_ref;
			// need to transform all the model points
			
		m.transform (
					p.x, p.y, p.z, 
					p.rx, p.ry, p.rz, 
					p.sx, p.sy, p.sz);

		
			// do projection matrix.
		MatrixVectorArrayMultiply ( ProjectionMatrix, m.vertices, m.vertices);
//		MatrixVectorArrayMultiply ( m.vertices,ProjectionMatrix, m.vertices);
		
			// finally do divide by w 	
		for (k = 0; k < m.vertices.length; k += 4)
		{
			w = m.vertices[k+3];
			if (w != 0)
			{
				m.vertices[k+0] /= w;
				m.vertices[k+1] /= w;
				m.vertices[k+2] /= w;
			}
		}
	
			// convert to screen coords.
		c = 0;
		for (k = 0; k < m.faces.length; k += 3)
		{
			v0 = m.faces[k+0] * 4;
			v1 = m.faces[k+1] * 4;
			v2 = m.faces[k+2] * 4;
			
//			z = 0;
			x0 = ox + (halfwidth * m.vertices[v0]);
			y0 = oy + (halfheight* m.vertices[v0+1]);
			z0 = m.vertices[v0+2];

			x1 = ox + (halfwidth *m.vertices[v1]);
			y1 = oy + (halfheight*m.vertices[v1+1]);
			z1 = m.vertices[v1+2];
			
			x2 = ox + (halfwidth * m.vertices[v2]);
			y2 = oy + (halfheight *m.vertices[v2+1]);
			z2 = m.vertices[v2+2];

			if (once == 0) console.log ("k:" + k + " z0 " + z0 + " z1 " + z1 + " z2 " + z2 + " ink:" + colours[c]);
			z = (z0 + z1 + z2)/3;			

			if ( _BackfaceCullCheck (x0,y0,x1,y1,x2,y2) > 0)
			{
				z = z;		// convert z to draw list range. 
				DrawList_AddItem (i, z, x0,y0,x1,y1,x2,y2, colours[c]);
			}
			c = (c + 1) & 7;
		}
 	}
}

function MoveCameraTest()
{
	var r;

	var x;
	var y;
	var z;

	var cos_a;
	var sin_a;
	var a;

	r = 10;

	a = (CameraAngle * Math.PI)/180;
	cos_a = r * Math.cos (a);
	sin_a = r * Math.sin (a);

	x = r * cos_a;
	y = 0;
	z = r * sin_a;
	
	x = 0;
	y = 0;
	z = -50;

//	x = 0;
//	y = r * cos_a;
//	z = r * sin_a;

	CameraAngle += 0.25;
	while (CameraAngle >= 360)
	{
		CameraAngle -= 360;
	}

	Camera.setCamera (x,y,z, 0,0,0);
}

var busy = false;

function UpdateGame()
{
	var i;
	if (busy == true)
	{
		return;
	}
	busy = true;
	requestAnimationFrame (UpdateGame);
	UpdateFrameCounter();

	if (!Ctx)	return;

	Ctx.clearRect(0,0,Canvas.width, Canvas.height);
	
	for (i = 0; i < TestObjects.length; i++)
	{
		TestObjects[i].ry += (i/30);
		TestObjects[i].rx += (1/2);
	}

//	MoveCameraTest();
	CreateDrawList(TestObjects);
	Draw_DrawList();
	busy = false;
	once = 1;
}

function InitInputs()
{
	// TO DO : Keyboard, mouse, touchscreen, joystick.
}

function BigCanvas()
{
	// you don't scale the canvas, but scale the outer container.
	// scale canvas square to fit 
	var w;
	var h;
	
	var item;

	w = window.innerWidth;
	h = window.innerHeight;
	
	item = document.getElementById ("area");
	if (w > h)
	{
		item.style.width= h + "px";
		item.style.height= h + "px";
	}
	else
	{
		item.style.width = w + "px";
		item.style.height = w + "px";
	}
}

function InitMap()
{
	var x;
	var y;
	var i;
	
	x = 0;
	y = -10;

	i = 0;
	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 0;
	TestObjects[i].y = 0;
	TestObjects[i].z = 7;
	i++;

/*
	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 4;
	TestObjects[i].y = 4;
	TestObjects[i].z = 0;
	i++;

	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 9;
	TestObjects[i].y = 2;
	TestObjects[i].z = 0;
	i++;
*/

//	TestObjects[i] = new Object3D (TestModel);
//	TestObjects[i].x = -5;
//	TestObjects[i].y = 0;
//	TestObjects[i].z = 0;
//	i++;

/*
	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 0;
	TestObjects[i].y = 5;
	TestObjects[i].z = 0;
	i++;

	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 0;
	TestObjects[i].y = -5;
	TestObjects[i].z = 0;
	i++;

	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 0;
	TestObjects[i].y = 0;
	TestObjects[i].z = 5;
	i++;

	TestObjects[i] = new Object3D (TestModel);
	TestObjects[i].x = 0;
	TestObjects[i].y = 0;
	TestObjects[i].z = -5;
	i++;
*/
/*	for (i = 0; i < TestMap.length; i++)
	{
		TestObjects[i] = new Object3D (TestModel);
		TestObjects[i].x = -4.5 + (x);
		TestObjects[i].y = y*0.5;
		TestObjects[i].z = -20;
		TestObjects[i].sz = 0.08;
		TestObjects[i].sy = 0.25;
		TestObjects[i].sx = 0.5;
		x++;
		if (x >= 10)
		{
			x = 0;
			y++;
		}
	}
*/
}

function DoInits()
{
	var w;
	var h;
	Canvas = document.getElementById("gc");
	Ctx = Canvas.getContext("2d");

	var i;
	
	BigCanvas();
	
	InitInputs();
	
	Ctx.beginPath();
	Ctx.moveTo (10,10);
	Ctx.lineTo (100,100);

	Ctx.moveTo (380,380);
	Ctx.lineTo (200,200);
	Ctx.stroke();

	w = Canvas.width;
	h = Canvas.height;
	ProjectionMatrix = Matrix_CreatePerspectiveProjectionMatrix
			(w, h, 
				30,			//field_of_view, 
				near_z,			//z_near, 
				far_z			// z_far)
			);

	Camera = new Cam3D(
							0,0,-40,
							0,1,0,
							0,0,0);

	TestModel = new Model3D (vertices, faces);

	InitMap();
/*
	for (i = 0; i < 30; i++)
	{
		TestObjects[i] = new Object3D (TestModel);
		TestObjects[i].x = -3 + (Math.random() * 6);
		TestObjects[i].y = -3 + (Math.random() * 6);
		TestObjects[i].z = -15 - (Math.random() * 40);
		TestObjects[i].sx = 0.1 + (Math.random());
		TestObjects[i].sy = 0.1 + (Math.random());
		TestObjects[i].sz = 0.1 + (Math.random());
	}
*/

	ClearDrawList();
	DrawList_AddItem (0, 10, 10,10, 50,50, 30,270, "#ff0000"); //  DrawList_AddItem (object_index, object_z, x0,y0,x1,y1,x2,y2, rgbhex)
	DrawList_AddItem (0, 20, 20,10, 240,50, 30,90, "#00ff00");
	DrawList_AddItem (0, 40, 30,10, 120,240, 30,90, "#00ffff");

	CreateDrawList(TestObjects);

	Draw_DrawList();
	
	UpdateGame();	
}

</script>


</head>
<body onload ="DoInits();">
<p id="fps">X</p>
<!--	<div class="topcornerimage"><a href="index.html"><img src="images/panda_small.png"></a></div> -->
	<div class="outer">
		<div class="container" id="area">
			<canvas class="gamecanvas" id="gc" width="384px;" height="384px;"></canvas>
		</div>
	</div>
	
</body>
</html>
