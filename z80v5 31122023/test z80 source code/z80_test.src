;	test code version 0.2	8th October 2023

;	version	0.3

;	updated	23rd October 2023

;
;	 Notes:
;	---------
;	Added some fairly basic 32 bit maths routines that could be used
;	for some simple 16.16 format fixed point maths.
;
; sqrt (0x353620ef) = 74B6
;
;	17th September 2023
;---------------------------
;	Added code to allow integer sine table multiply
;
;	so hl = de * sin (a) 	where a is an angle from 0..255 (instead of 0..360)
;
;	and... it works !!!
;
;	going to add de * cos(a), which is just a table reading shift :-)
;
;
;	 18th September 2023
;	-----------------------
;	Added experimental 24 pixel wide sprite routine. Currently just or's 
; a rotated block of 3 bytes (24 pixels) to the screen.
;
;
;	 20th September 2023
;	---------------------
;	Found a nice little circle algorithm on wikipedia so added it..
;	If i can figure out how to draw it quickly it would be awesome.
;
;
;	 21st September 2023
;	------------------------
;	Per pixel, the circle drawing routine is slow, as the screen address
;	is calculated each time, so going to try and buffer the pixel 
;	coordinates and then just draw down the screen.
;
;	 22nd September 2023
;	----------------------
;	adding some collision test code.
;
;
;	 14th September 2023
;	------------------------
;	Added simple run length decoding routine.
;
;
;	 29th September 2023
;	----------------------
;	Fixed bug in draw line routine when comparing 2 8 bit values.
;
;	e.g	e is a value in range [0..255]

;		add a,d		<--- will always be greater than e if a carry occurs.
;					; so no need to test against e, can just do the jump.
;
;
;
;	sign extend 8 to 16 bit:
;
;	ld l,a	; store low bit
;	add a,a	; push sign into carry
;	sbc a,	; turn it into 0 or -1
;	ld h,a	;
;
;	sign extend de (16) to 32 bit (hlde)
;
;	ld h,d
;	add hl,hl
;	sbc hl,hl
;
;
;	 8th October 2023
;	----------------------
;	rewriting bezier curve routine as tests show they just dont really
;	work for 8 bit unsigned values. Found a nice signed 16 bit 
;	multiply routine that helps.
;
;
;
;	 13th October 2023
;	---------------------
;	Wrote some raster-chasing map drawing code. Its good, and gives 
;	a reasonable frame rate approx 25 frames per second... however..
;	It doesn't leave much room for the actual game code to run so
;	I figure the difference between 25 frames a second and maybe 23-24
;	frames isnt all that noticable.. so going to try use a screen 
;	buffer to reduce the timing problems.
;
;	Screen Buffer Address: 57344 (65536-8192),leaves space for 
;	tables and attribute map copy.
;
;	address	size	description
;	0xE000	6144	57344	screen buffer
;	0xF800	768		63488	screen buffer attribute map
;	0xFB00	384		64256	row table (192 rows, 384 bytes)
;	0xFC80			64640 (896 bytes available for doing shit with!!)
;
;
;	 15th October 2023
;	---------------------
;	Working on getting the map scrolling.. toying with the idea of
;	storing the main map as either a byte per map character, or 4 bits
;	- going with a byte for now, to allow for up to 256 16x16 character
;	which would be about 8k of graphics data required for all 256 characters.
;
;	The main map is stored uncompressed, so this means each map row
;	has to be decompressed into the map. If I limit the scroll to less
;	than 16 pixels, then I should only ever have to decompress the 
;	edges of the map. 
;
;	Decided to only handle vertical scroll
;
;
;	 17th October 2023
;	--------------------
;	Working on getting the map colour attributes working while listening
;	to a *lot* of old 80's tunes for the full retro experience !!
;
;
;	 19th October 2023
;	--------------------
;	Getting scroll down to work today hopefully.
;	scrolling works.. just got to get the attribute map movement timing
;	right, to avoid crappy flicker.
;
;
;	 22nd October 2023
;	--------------------
;	Going to just abandon the attribute idea for now - the flicker 
;	problem is just too annoying for a smooth vertical scroll where
;	sprites have to interact with the background.
;
;
;	 23rd October 2023 
;	-------------------
; Adding some basic point-in-slope collision detection stuff to handle
; 22.5, 45 and 67.5 degree slopes (may add extra code to do more slopes
; now I know the formula's to use !!! :-D
;
;
;


ink_black:		equ 0
ink_blue:		equ 1
ink_red:		equ 2
ink_magenta:	equ 3
ink_green:		equ 4
ink_cyan:		equ 5
ink_yellow:		equ 6
ink_white:		equ 7

paper_black:	equ 0
paper_blue:		equ 8	;(1<<3)
paper_red:		equ (2<<3)
paper_magenta:	equ (3<<3)
paper_green:	equ (4<<3)
paper_cyan:		equ (5<<3)
paper_yellow:	equ (6<<3)
paper_white:	equ 56	;(7<<3)

	; screen character row addresses :
CHROW0:		equ 0x4000
CHROW1:		equ 0x4020
CHROW2:		equ 0x4040
CHROW3:		equ 0x4060
CHROW4:		equ 0x4080
CHROW5:		equ 0x40A0
CHROW6:		equ 0x40C0
CHROW7:		equ 0x40E0
CHROW8:		equ 0X4800
CHROW9:		equ 0x4820
CHROW10:	equ 0x4840
CHROW11:	equ 0x4860
CHROW12:	equ 0x4880
CHROW13:	equ 0x48A0
CHROW14:	equ 0x48C0
CHROW15:	equ 0x48E0
CHROW16:	equ 0x5000
CHROW17:	equ 0x5020
CHROW18:	equ 0x5040
CHROW19:	equ 0x5060
CHROW20:	equ 0x5080
CHROW21:	equ 0x50A0
CHROW22:	equ 0x50C0
CHROW23:	equ 0x50E0

MEMBOT:		equ 23698
BITLIST:	equ MEMBOT

SCREEN_BUFFER:	equ 0xE000				; 57344
ATTR_BUFFER:	equ SCREEN_BUFFER+6144



KEY_CAPS: equ	(0*32)+1	; *ZXCV
KEY_Z:	equ	(0*32)+2
KEY_X:	equ	(0*32)+4
KEY_C:	equ	(0*32)+8
KEY_V:	equ	(0*32)+16

KEY_A:	equ	(1*32)+1		; ASDFG
KEY_S:	equ	(1*32)+2
KEY_D:	equ	(1*32)+4
KEY_F:	equ	(1*326)+8
KEY_G:	equ	(1*32)+16
	
KEY_Q:	equ	(2*32)+1		; QWERT
KEY_W:	equ	(2*32)+2
KEY_E:	equ	(2*32)+4
KEY_R:	equ	(2*32)+8
KEY_T:	equ	(2*32)+16

KEY_1:	equ	(3*32)+1		; 12345
KEY_2:	equ	(3*32)+2
KEY_3:	equ	(3*32)+4
KEY_4:	equ	(3*32)+8
KEY_5:	equ	(3*32)+16

KEY_0:	equ	(4*32)+1		; 09876
KEY_9:	equ	(4*32)+2
KEY_8:	equ	(4*32)+4
KEY_7:	equ	(4*32)+8
KEY_6:	equ	(4*32)+16

KEY_P:	equ	(5*32)+1		; POIUY
KEY_O:	equ	(5*32)+2
KEY_I:	equ	(5*32)+4
KEY_U:	equ	(5*32)+8
KEY_Y:	equ	(5*32)+16

KEY_ENTER:	equ	(6*32)+1		; +LKJH
KEY_L:	equ	(6*32)+2
KEY_K:	equ	(6*32)+4
KEY_J:	equ	(6*32)+8
KEY_H:	equ	(6*32)+16

KEY_SPC:	equ	(7*32)+1		; ;#MNB
KEY_SS:	equ	(7*32)+2
KEY_M:	equ	(7*32)+4
KEY_N:	equ	(7*32)+8
KEY_B:	equ	(7*32)+16



test:	equ 192 / 2

bright:		equ 64
flash:		equ 128		; included for completeness, I never actually use it !

	org 24576
;	di

	ld a,(ix)

	ld hl,300
	ld (map_y),hl

	call InitRowTable
	call InitBitTable

	ld a, ink_white + paper_black + bright
	call ClearScreenBuffer

	ld a, 65		; 104	;	128
	ld (px),a
	ld a, 35		; 96
	ld (py),a

	jr blackcat

py: defb 0
px:	defb 0

	ld e,0
	ld c,50
	call DrawPixel

blackcat:

	ld a,(px)
	ld c,a
	ld a,(py)
	ld e,a
	call DrawPixel

	call ReadKeyboard
	
	ld a,KEY_5
	call IsKeyPressed
	call nz, left

	ld a,KEY_6
	call IsKeyPressed
	call nz, down

	ld a,KEY_7
	call IsKeyPressed
	call nz, up

	ld a,KEY_8
	call IsKeyPressed
	call nz, right

	jr nokeypressed

left:
	ld a,(px)
	and a
	ret z
	dec a
	ld (px),a
	ret

right:
	ld a,(px)
	cp 255
	ret z
	inc a
	ld (px),a
	ret

up:
	ld a,(py)
	and a
	ret z
	dec a
	ld (py),a
	ret

down:
	ld a,(py)
	cp 191
	ret z
	inc a
	ld (py),a
	ret

	
nokeypressed:

	call DrawScreenBuffer

	call DoSlopeTest

;lpwait:	jr lpwait

	jr blackcat

	; call with hl and de with the slope coordinates and bc the point to test
	;	h = x0, l = y0, d = x1, e = y1, b = px, c = py

	; call with:
	; b = x0
	; c = y0
	; d = x1
	; e = y1

DoSlopeTest:
	ld hl,SlopeTestData
	ld b,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	
	call DrawLine
	call DrawScreenBuffer

	ld hl,SlopeTestData
	ld d,(hl)			; d = x0
	inc hl
	ld e,(hl)			; e = y0
	inc hl
	ld a,(hl)			; a = x1
	inc hl
	ld l,(hl)			; l = y1
	ld h,a

	ex de,hl			; h = x0 , l = y0, d = x1, e = y1

	ld a,(px)
	ld b,a
	ld a,(py)
	ld c,a

	ld a,paper_blue
	ld (ATTR_BUFFER+10),a

	call PointInSlope
	push af
	call DrawScreenBuffer
	pop af

	and a
	ld a, paper_blue
	jr z, wwwggg
	ld a, paper_red
wwwggg:
	ld hl, ATTR_BUFFER
	ld (hl),a
	
	ret


SlopeTestData:
;	defb 50,20				; x0,y0
;	defb 82,52				; x1,y1

	defb 50,20
	defb 66,52

;	defb 220,20
;	defb 252,36

;	defb 100,52
;	defb 164,20

;	defb 100,52				; x0,y0
;	defb 132,20				; x1,y1




	ld de, SCREEN_BUFFER+6144+768-64
	ld h,d
	ld l,e
	ld de,SCREEN_BUFFER+6144
	ld a,0
	ld b,64
blackout_row0:
	ld (de),a
	ld (hl),a
	inc e
	inc l
	djnz blackout_row0

	ld b,3
	ld de,0
	ld hl,0
lp000:
	push bc
	push de
	push hl
;	call map_uncompress_row
	pop hl
	inc hl
	pop de
	inc de
	pop bc
	djnz lp000

	; de = map row [0..11]
	; hl = map_character_map row [0..100]

	call DrawMap
	call DrawMapAttr


	ei

rave_repeat:
	call WaitVBL

	; 48k spectrum:
	;	224 t-states per line
	;	64 lines before scanline starts to draw the display
	;	14336 t-states delay before screen drawing starts.

	; 128k spectrum:
	;
	;

	; (4 + 12) * 256



;	ld hl,(tmp000)			; 200 seems low, but allowing speccy interrupts to exist which take a lot of the timing ??

;	ld hl,597
;	ld hl,400

;	inc hl
;	ld a,h
;	and 31
;	ld h,a
;	ld (tmp000),hl
;delay101:
;	dec hl				; 6
;	ld a,h				; 4
;	or l				; 4
;	jp nz,delay101		; 10

;	ld b,58
;delay102:
;	ld c,15
;delay101:				; approx 16 t states per inner loop
;	dec c				; 4
;	jr nz,delay101		; condition met 12, not met 7
;	djnz delay102		; b != 0, 13,		b = 0  8

	call MoveMapDown
;	call MoveMapUp

	call DrawMap
;	call DrawMapAttr

	ld de,TestString
	ld b,4
	ld c,2
	ld a,12
	call DrawString


	ld c,128
	ld e,20
	ld b,128
	ld hl, testsprite16
	call DrawSprite16

;	ld a,(map_offset)
;	sub 2
;	and 15
;	ld (map_offset),a
;	jr nz,ggg0
;	call z,map_scroll_up
;	ld a,(map_offset)
;	ld (map_offset),a
;ggg0:
	
	
	call DrawScreenBuffer
	
	jr rave_repeat
	
;	call DrawMap0
;	call DrawMap2
;	call DrawMap4
;	call DrawMap6
	
loop_forever:
	jr loop_forever

tmp000:	defw	1



	ld hl,curve_two	;curve_x0
	ld b,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	dec hl
	push hl
	call DrawLine
	pop hl
;	ld hl,curve_x1
	ld b,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	call DrawLine

	xor a
	ld (curve_t),a
	ld hl,curve_points
quadloop:
	push hl
	ld hl,curve_two		;curve_x0
	
	call get_quadratic_bezier_point		; returns h = px, l = py
	ld d,h
	ld e,l
	pop hl
	ld (hl),d
	inc hl
	ld (hl),e
	inc hl
	ld a,(curve_t)
	inc a
	ld (curve_t),a
	cp 17
	jr nz, quadloop

	ld hl,curve_points
	ld b,16
asdf0:
	push bc
	ld b,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	dec hl
	push hl
	call DrawLine
	pop hl
	pop bc
	djnz asdf0

;	call DrawScreenBuffer


;	jp rave_repeat

halt


curve_t:	defb 0
curve_one:
curve_x0:	defb 100
curve_y0:	defb 30
curve_x1:	defb 40
curve_y1:	defb 120
curve_x2:	defb 150
curve_y2:	defb 70

curve_two:
	defb 220	;x0
	defb 180	;y0
	defb 30		; x1
	defb 5		; y1
	defb 4		; x2
	defb 160	; y2

curve_points:
			defm	36		; 17 points.

	ld de,hello_string
	ld b,16
	ld c,2
	ld a,12
	call DrawString
	jr skp00
hello_string:	defs 'HELLO World.'
skp00:


	ld a,33			;	a = char code (0..127)
	ld d,8		;	d = x coord (0..255)
	ld e,12		;	e = y coord (0..255)
	
	ld b,94
nxtch0:
	push bc
	push af
	push de

	call font_draw_char
	
	pop de
	ld a,d
	add a,9
	ld d,a
	ld a,e
	add a,1
	ld e,a
	pop af
	inc a
	pop bc
	djnz nxtch0


halt

	
;	ld hl, 40960
;	ld de, 16384+6144
;	call rle_decode

	ld a,1

	ld c,1			; y0
	
lp8484:
	push af
	ld b,0			; x0
	ld d,a		;200		; x1
	ld e,50		; y1

;	push bc
;	push de
;	ld c,d
;	call DrawPixel
;	pop de
;	pop bc


;	ld b,2			; x0
;	ld c,1			; y0
;	ld d,100		; x1
;	ld e,95		; y1


	push bc
	push de
	call DrawLine
	
	pop de
	pop bc
	
	ld a,c
	add a,3
	ld c,a

	
	pop af
	add a,4
	jr nc, lp8484
	
halt
		; b = x0 [0..255]
		; c = y0 [0..191]
		; d = x1 [0..255]
		; e = y1 [0..191]

;	call calc_line_length

	ld a,65			;	a = char code (0..127)
	ld d,33		;	d = x coord (0..255)
	ld e,12		;	e = y coord (0..255)
	call font_draw_char


halt
	
	ld b,100
	ld c,120
	ld e,20
	call DrawDoublePixel
	

	ld b,32
	ld a,0
	ld (posx),a
	ld (posy),a
lp939:	
	push bc

	ld a,(posx)
	ld c,a
	inc a
	ld (posx),a
	ld a,(posy)
	ld e,a
	add a,4
	ld (posy),a
	ld b,24
	ld hl, testsprite24
	call DrawSprite24


	ld c,180
	ld e,20
	ld b,16
	ld hl, testsprite16
	call DrawSprite16

	ld b,8
	ld c,128
	ld e,96
	ld hl, testsprite8
	call DrawSprite8

	pop bc
	djnz lp939

	ld c,100
	ld e, 60			;192 / 2
	call DrawPixel

	ld b,40
	ld c,1
lpgg9:
	push bc
	
	ld e,c

	ld a,90
	add a,b
	add a,b
	add a,b
	add a,b
	ld c,a
	ld b, 90			; b = cy
;	ld c, 100			; c = cx
	call DrawCircle
	
	pop bc
	inc c
	inc c
	djnz lpgg9
	
	call RandomHL
	ld de, MyString
	call NumToAsciiString

	ld de,MyString
	ld b,10
	ld c,4
	ld a,5
	call DrawString


halt

posx:	defb 0
posy:	defb 0

MyString:	defb 0,0,0,0,0

;	ld a,5
;	call reciprocal_a
;	halt

;	ld a,210
;	call div_a_10

;	ld hl,1
;repeatforever:
;	push hl
;ld de, MyString
;call NumToAsciiString
	
;	ld de,MyString
;	ld b,10
;	ld c,4
;	ld a,5
;	call DrawString
	
;	pop hl
;	inc hl
;	jr repeatforever
;halt




;	ld de,teststring
;	ld b,10
;	ld c,4
;	ld a,5
;	call DrawString
	
	
;	ld b,8
;	ld hl, ROW4 + 10
;lp44:
;	push bc
;	push hl

;	ld b,5
;	call reverse_data_block
	
;	pop hl
;	call IncRow
;	pop bc
;	djnz lp44

	
;halt



;teststring:	defs 'HELLO World.'

	ld b,10			; b = character column x (0-31)
	ld c,4			; c = character row y (0-23)
	ld a,64			; a = ch to draw
	call DrawCh
;halt


	ld c,10
	ld e, 10			;192 / 2
	call DrawPixel

	ld c,100
	ld e, 50		;192 / 2
	call DrawPixel

	ld c,50
	ld e, 100		;192 / 2
	call DrawPixel


	ld b,10		; b = x0
	ld c,10		; c = y0
	ld d,100	; d = x1
	ld e,70		; e = y1
	call DrawLine

	ld b,140	; b = x0
	ld c,20		; c = y0
	ld d,150	; d = x1
	ld e,70		; e = y1
	call DrawLine

	ld b,250	; b = x0
	ld c,100	; c = y0
	ld d,180	; d = x1
	ld e,120	; e = y1
	call DrawLine

	ld b,240	; b = x0
	ld c,120	; c = y0
	ld d,220	; d = x1
	ld e,190	; e = y1
	call DrawLine



	ld b,45	; b = x0
	ld c,96		; c = y0
	ld d,210		; d = x1
	ld e,96	; e = y1
	call DrawLine
	
	; draw sine curve test
	
	ld b,0		; b = loop counter, angle and x coord
	ld hl, 32	; hl = radius

lp8:
	push bc
	push hl
	
	ld a,b			; a = angle, 0..255
	ex af,af

	ld e,l
	ld d,h
	ld a,b
	
;	call mul_de_sin_a		; hl = result
	call mul_de_cos_a		; hl = result
	
	ld a,96
	sub l
	ld e,a

	ex af,af
	ld c,a

	call DrawPixel

	pop hl
	pop bc
	inc b
	ld a,b
	and a
	jr nz,lp8

halt;	
	



		; draw line inner loop test.

;	ld hl,16384 + 40	; hl = screen position
;	ld c,128			; c = bit data to plot with
;	ld d,12				; d = dx
;	ld e,7				; e = dy
;	xor a				; a = error adjust 
;	ld b,120			; b = loop length.

;bob:
;	ex af,af		; store af
;	ld a,(hl)
;	or c			; c = bit position to 
;	ld (hl),a
;	ex af,af
;;	add a,e			; d = dx
;	cp d
;	jr c,skip
;	sub d
;	rlc c
;	jr nc, skip
;	dec l
;skip:
;	ex af,af
;	call IncRow
;	ex af,af
;	djnz bob



	
	ld c,120
	ld e, 6			;192 / 2
	call DrawPixel

	ld c,136
	ld e, 6			;192 / 2
	call DrawPixel

;	vertical line tests
;	ld b,96
;	ld c,50
;	ld d,95
;	ld e,96
;lp22:
;	push bc
;	push de
;	call DrawVerticalLine
;	pop de
;	pop bc
;	inc c
;	dec e
;	inc d
;	djnz lp22

;	ld e,8
;	ld b,120
;	ld c,136
;	push bc
;	push de
;	call DrawHorizontalLine
;	pop de
;	pop bc
;	inc e
;	call DrawHorizontalLine
	

	; horizontal line tests
	ld h,128		; x0
	ld l,128		; x1
	ld b,100
	ld c,3			; y
lp99:
	push bc
	push hl
	ld e,c
	ld b,h
	ld c,l
	call DrawHorizontalLine
	pop hl
	dec h
	inc l
	pop bc
	inc c			; y++
	djnz lp99

halt

;	ld hl,0
;	ld bc,2048
;	ld de,16384
;	ldir

	; maths test
;	ld hl,0
;	ld de,75
;	push hl			; push high word first
;	push de

;	sqrt(0x353620EF) = 
	ld hl, 0x3536
	ld de, 0x20EF
	push hl
	push de

	jp sqrt_a
next_op:
	pop de
	pop hl
	
	halt
;loop_forever:
;	jr loop_forever
	
;	16.16 bit fixed point maths routines
;	stack based calculator routines.
; (probably not the best thing to be writing with a head full of covid!

	; *******************************************************
	;            16.16 fixed point maths routines
	; notes : dont care about overflow or underflow..just want
	; a basic set of maths routines:
	;	add, sub, mul, div, rem
	;	neg, not, and, or, xor, abs
	;	floor
	; *******************************************************

	; 32 bit multiplier (not optimised)
mul_al:	defw 0
mul_ah:	defw 0
mul_bl:	defw 0
mul_bh:	defw 0
mul_rl:	defw 0
mul_rh:	defw 0

mul_32:
	sbc hl,hl		; ld hl,0
	ld (mul_rl),hl
	ld (mul_rh),hl
	ld b,32			; 32 bits to process
mul_lp0:

	; shift result 1 bit
	ld hl,(mul_rl)
	add hl,hl
	ld (mul_rl),hl
	ld hl,(mul_rl)
	adc hl,hl
	ld (mul_rh),hl
	
	; shift B
	ld hl,(mul_bl)
	add hl,hl
	ld (mul_bl),hl
	ld hl,(mul_bh)
	adc hl,hl
	ld (mul_bh),hl
	jr nc,mul_lp1		; test the highest bit
	
	; add R + A
	ld hl,(mul_al)
	ld de,(mul_rl)
	add hl,de
	ld (mul_rl),hl
	ld hl,(mul_al)
	ld de,(mul_rh)
	adc hl,de
	ld (mul_rh),hl

mul_lp1:
	djnz mul_lp0
	ret





	; >> push a 16.16 fixed point number onto the stack

push_1616:
	; hl = high word
	; de = low word
	push hl
	push de
	jp next_op
	
	; >> pop a 16.16 fixed point number from the stack (for returning the result ???

	; hl = high word
	; de = low word
pop_1616:
	pop de
	pop hl
	jp next_op

	; push 10.0 onto the stack

push10:
	ld hl,10
	push hl		; high word = 10
	ld l,h
	push hl		; low word = 0
	jp next_op

	; push PI onto the stack

pushpi:
	ld hl,3
	push hl
	ld hl, 9279		;  = (3.141592653589793 * 65536) & 0xFFFF
	push hl
	jp next_op
	
	; and (a,b)
and_ab:
	pop de	;	- low byte(a)
	pop bc	;	- high byte(a)
	pop hl 	;	- low byte(b)
	ld a,e
	and l
	ld e,a
	ld a,d
	and h
	ld d,a	; 	de = low(a) and low(b)
	pop hl 	; hl = high byte(b)
	ld a,c
	and l
	ld c,a
	ld a,b
	and h
	ld b,a	;	bc = high(a) and high(b)
	push de
	push bc
	jp next_op

	; or (a,b)
or_ab:
	pop de	;	- low byte(a)
	pop bc	;	- high byte(a)
	pop hl 	;	- low byte(b)
	ld a,e
	or l
	ld e,a
	ld a,d
	or h
	ld d,a	; 	de = low(a) or low(b)
	pop hl 	; hl = high byte(b)
	ld a,c
	or l
	ld c,a
	ld a,b
	or h
	ld b,a	;	bc = high(a) and high(b)
	push de
	push bc
	jp next_op

	; xor (a,b)
xor_ab:
	pop de	;	- low byte(a)
	pop bc	;	- high byte(a)
	pop hl 	;	- low byte(b)
	ld a,e
	xor l
	ld e,a
	ld a,d
	xor h
	ld d,a	; 	de = low(a) or low(b)
	pop hl 	; hl = high byte(b)
	ld a,c
	xor l
	ld c,a
	ld a,b
	xor h
	ld b,a	;	bc = high(a) and high(b)
	push de
	push bc
	jp next_op
	
	; floor (a)
floor_a:
	pop hl		; just pops the low word and sets it to zero
	sbc hl,hl	;	 shorter version?? of ld hl,0
	push hl
	jp next_op

	; >> not (n)
not_a:
	pop de		; de = low word
	pop bc		; bc = high word
	sbc hl,hl	;ld hl,0
	scf			; set carry
	sbc hl,de
	ex de,hl
	ld hl,0
	sbc hl,bc
	ld b,h
	ld c,l
	push bc
	push de
	jp next_op

	; neg (a)
neg_a:
	pop de		; de = low word
	pop bc		; bc = high word
neg_num_abs:
	sbc hl,hl	; ld hl,0
	and a		; clear carry
	sbc hl,de
	ex de,hl
	ld hl,0
	sbc hl,bc
	ld b,h
	ld c,l
	push bc
	push de
	jp next_op
	
	; abs (a)
abs_a:
	pop de		; de = low word
	pop bc		; bc = high word
	bit 7,b
	jr nz, neg_num_abs
	push bc
	push de
	jp next_op

	; add a,b
add_ab:		
	and a			; clear carry
	pop hl			; low word b
	pop de			; high word b
	pop bc			; bc = low word a
	adc hl,bc		;	hl = low(a) + low(b)
	pop bc			; bc = high word a (as done with low word)
	ex de,hl		; de = low (result)
	adc hl,bc		;	hl =high(a) + high(b)
	push hl			; store high word first
	push de			; store low word last.
	jp next_op		; jp to do next operation.

	; sub a,b
sub_ab:		
	and a			; clear carry
	pop hl			; low word b
	pop de			; high word b
	pop bc			; bc = low word a
	sbc hl,bc		;	hl = low(a) - low(b)
	pop bc			; bc = high word a (as done with low word)
	ex de,hl		; de = low (result)
	sbc hl,bc		;	hl =high(a) - high(b)
	push hl			; store high word first
	push de			; store low word last.
	jp next_op		; jp to do next operation.
	
	; mul a*b
	; hard to do as 16.16 * 16.16 needs more bits than are available.
	; so just going for a straightforward solution using memory
	; in place of registers.

;mul_AL:	defw 0
;mul_AH:	defw 0

;mul_BL:	defw 0
;mul_BH:	defw 0

;mul_RL:	defw 0
;mul_RH:	defw 0

mul_ab:
	pop hl
	ld (mul_al),hl
	pop hl
	ld (mul_ah),hl
	pop hl
	ld (mul_bl),hl
	pop hl
	ld (mul_bh),hl
	
	call mul_32

	ld hl,(mul_rh)
	push hl
	ld de,(mul_rl)
	push de
	jp next_op
	
;	sbc hl,hl		; ld hl,0
;	ld (mul_rl),hl
;	ld (mul_rh),hl

;	ld b,32			; 32 bits to process

;mul_lp0:

;	; shift R
;	ld hl,(mul_RL)
;	add hl,hl
;	ld (mul_RL),hl
;	ld hl,(mul_RH)
;	adc hl,hl
;	ld (mul_RH),hl
	
;	; shift B
;	ld hl,(mul_BL)
;	add hl,hl
;	ld (mul_BL),hl
;	ld hl,(mul_BH)
;	adc hl,hl
;	ld (mul_BH),hl
;	jr nc,mul_lp1		; test the highest bit
	
;	; add R + A
;	ld hl,(mul_AL)
;	ld de,(mul_RL)
;	add hl,de
;	ld (mul_RL),hl
;	ld hl,(mul_AH)
;	ld de,(mul_RH)
;	adc hl,de
;	ld (mul_RH),hl

;mul_lp1:
;	djnz mul_lp0
;	ld hl,(mul_RH)
;	push hl
;	ld de,(mul_RL)
;	push de
;	jp next_op
;

; div a/b
;	does a divided by b 
;
;	a = numerator, b = denominator
;
; from wikipedia division_algorithm page:
;if D = 0 then error(DivisionByZeroException) end
;Q := 0                  -- Initialize quotient and remainder to zero
;R := 0                     
;for i := n − 1 .. 0 do  -- Where n is number of bits in N
;  R := R << 1           -- Left-shift R by 1 bit
;  R(0) := N(i)          -- Set the least-significant bit of R equal to bit i of the numerator
;  if R ≥ D then
;    R := R − D
;    Q(i) := 1
;  end
;end

div_AL:	defw 0
div_AH:	defw 0

div_BL:	defw 0
div_BH:	defw 0

div_RL:	defw 0		; result (quotient)
div_RH:	defw 0

div_RML:	defw 0	; remainder
div_RMH:	defw 0

div_ab:
	pop hl
	ld (div_AL),hl
	pop hl
	ld (div_AH),hl
	pop hl
	ld (div_BL),hl
	pop hl
	ld (div_BH),hl

	call div_loop	; main div loop shared with remainder code.

	ld hl,(div_RH)
	push hl
	ld de,(div_RL)
	push de
	jp next_op
	

div_loop:
	sbc hl,hl		; ld hl,0
	ld (div_RL),hl
	ld (div_RH),hl
	ld (div_RML),hl
	ld (div_RMH),hl

	ld b,32			; 32 bits to process		


div_lp0:
	push bc

	; rotate top bit of numerator a into remainder store
	and a
	ld hl,(div_AL)
	add hl,hl
	ld (div_AL),hl

	ld hl,(div_AH)
	adc hl,hl
	ld (div_AH),hl
	ld hl,(div_RML)
	adc hl,hl
	ld (div_RML),hl
	ld hl,(div_RMH)
	adc hl,hl
	ld (div_RMH),hl
	
	; is remainder >= divisor b?
	;	testing R - D
	xor a			; a = 0
	ld hl,(div_RML)
	ld de, (div_BL)
	sbc hl,de
	ld b,h			; temp store hl 
	ld c,l
	ld hl,(div_RMH)
	ld de,(div_BH)
	sbc hl,de
	jr c, div_lp1

	ld (div_RML),bc		; store R - D
	ld (div_RMH),hl
	inc a				; a = 1
div_lp1:
	
	; shift R			; rotate result left and 
	rra					; shift a into lowest bit.
	ld hl,(div_RL)
	adc hl,hl
	ld (div_RL),hl
	ld hl,(div_RH)
	adc hl,hl
	ld (div_RH),hl
	pop bc
	djnz div_lp0
	ret

	; remainder a % b	calculates the remainder of a/b

rem_ab:
	pop hl
	ld (div_AL),hl
	pop hl
	ld (div_AH),hl
	pop hl
	ld (div_BL),hl
	pop hl
	ld (div_BH),hl

	call div_loop	; main div loop shared with remainder code.

	ld hl,(div_RMH)
	push hl
	ld de,(div_RML)
	push de
	jp next_op

	;	sqr(a)	calculates a * a
sqr_a:
	pop hl
	pop de
	push de
	push hl
	push de
	push hl
	jp mul_ab

sqrt_a:
	pop hl
;	ld (sqrt_NL),hl
	pop de
;	ld (sqrt_NH),hl
	call sqrt_32
	ld hl,(sqrt_RL)
	push hl
	ld de,(sqrt_RH)
	push de

	jp next_op


	; -------------------------------------------------------
	;		---- 32 bit integer square root ----
	; -------------------------------------------------------

	; sqrt (a)	calculates the square root of a
	; (not expecting great accuracy here!!)
	; based on code from http://www.retroprogramming.com/2017/07/a-fast-z80-integer-square-root.html
	
	; think this is called the bit-by-bit algorithm. (or digit by digit ??)

; 	numb = 12347;		// ans = 111.117...
;    root = 0;
;    bit = 0x40000000;		// large enough to handle 32 bits, goes through 16 iterations of loop in total.
   
;    while ( bit != 0 )
;    {
;		t = root + bit;
;        if ( numb >= t)	//root + bit )
;        {
;            numb = numb - t;	//root - bit;
;            root = Math.floor (root / 2 + bit);
;        }
;        else
;        {
;            root = Math.floor (root / 2)
;		}
;        bit = Math.floor (bit / 4);
;    }


sqrt_RL:	defw 0		; square root store
sqrt_RH:	defw 0

sqrt_BL:	defw 0		; bit
sqrt_BH:	defw 0

sqrt_NL:	defw 0		; original number (32 bits)
sqrt_NH:	defw 0

sqrt_TL:	defw 0		; temp store
sqrt_TH:	defw 0

sqrt_32:	; start of 32 bit square root routine.

	; call with 32 bit number in de.hl

	ld (sqrt_NL),hl
	ld (sqrt_NH),hl

	sbc hl,hl		;ld hl,0
	ld (sqrt_RL),hl		; root = 0
	ld (sqrt_RH),hl
	ld (sqrt_BL),hl
	ld hl,0x4000
	ld (sqrt_BH),hl

sqrt_loop:
			; calc (root + bit) and store in temp var.
	ld hl, (sqrt_RL)
	ld de, (sqrt_BL)
	add hl,de
	ld (sqrt_TL),hl
	ld hl, (sqrt_RH)
	ld de, (sqrt_BH)
	adc hl,de
	ld (sqrt_TH),hl

	; numb >= (root + bit)	test ->  doing numb - (root + bit) and testing carry flag
	ld hl, (sqrt_NL)
	ld de, (sqrt_TL)		; root + bit is stored in temp var.
	and a
	sbc hl,de
	ld b,h
	ld c,l

	ld hl,(sqrt_NH)
	ld de,(sqrt_TH)
	sbc hl,de
	jr c, sqrt_lp1

	ld (sqrt_NH),hl		; store numb = numb - (root + bit)
	ld (sqrt_NL),bc
	
	; root = (root / 2) + bit
	ld hl,(sqrt_RH)
	ld de,(sqrt_RL)
	srl h				; HL -> DE ->
	rr l
	rr d
	rr e
	ld bc,(sqrt_BL)
	ex de,hl			; hl = low, de = high
	add hl,bc
	ld (sqrt_RL),hl
	ld hl,(sqrt_BH)
	adc hl,de
	ld (sqrt_RH),hl
	jr sqrt_lp2

sqrt_lp1:	
			; root = (root / 2);
	ld hl,(sqrt_RH)
	ld de,(sqrt_RL)
	srl h				; HL -> DE ->
	rr l
	rr d
	rr e
	ld (sqrt_RH),hl
	ld (sqrt_RL),de
	
sqrt_lp2:

	; bit / 4 = two shifts to the right. z80 isnt designed for fast shifts !
	ld hl,(sqrt_BH)
	ld de,(sqrt_BL)
	
	srl h				; 0 -> h -> c
	rr l				; c -> l -> c
	rr d
	rr e
	srl h
	rr l
	rr d
	rr e
	ld (sqrt_BH),hl
	ld (sqrt_BL),de
	
	ld a,h				; test to see if bit == 0
	or l
	or d
	or e
	
	jp nz,sqrt_loop		; do loop again if it isnt

		; return with the square root in de.hl  (de should always be zero ???)
	ld hl,(sqrt_RL)
	ld de,(sqrt_RH)

	ret


	; ------------------------------------------------
	;	maths sine rountine and sine table
	;
	; note the range is 0..255 and not 0..360
	;	e.g.
	;	degrees		binary degrees
	;		0				0
	;		90				64
	;		180				128
	;		270				192
	;
	; ------------------------------------------------

sine256_table:
		;	values are stored as sin(a)*256
		; for the first 128 degrees (180 degrees)
		; the remaining values are just -ve these.

	defb 0,6,12,18,24,31,37,43,49,55,61,68,74,79,85,91
	defb 97,103,109,114,120,125,131,136,141,146,151,156,161,166,171,175
	defb 180,184,188,193,197,201,204,208,212,215,218,221,224,227,230,233
	defb 235,237,240,242,244,245,247,248,250,251,252,253,253,254,254,254
	defb 255,254,254,254,253,253,252,251,250,248,247,245,244,242,240,237
	defb 235,233,230,227,224,221,218,215,212,208,204,201,197,193,188,184
	defb 180,175,171,166,161,156,151,146,141,136,131,125,120,114,109,103
	defb 97,91,85,79,74,68,61,55,49,43,37,31,24,18,12,6


mul_de_cos_a:
	; 	de * sin(a)
	;	returns result in hl
	;	de = unsigned value
	;	hl = signed result.

	add a,64

	; fall through to sine routine : jr mul_de_sin_a

mul_de_sin_a:
	; 	de * sin(a)
	;	returns result in hl
	;	de = unsigned value
	;	hl = signed result.

	push af

	ld b,0
	and 127				; sine table only stores half the angles.
	ld c,a
	ld hl,sine256_table
	add hl,bc
	ld a,(hl)		;	a = value to multiply by.

	; using 16*8 multiply from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Multiplication

	; does a * de, puts the result in ahl (a = high byte of result, l = low byte)
mult_a_de:
	ld	c, 0
	ld	h, c
	ld	l, h

	add	a, a		; optimised 1st iteration   - why ???
	jr	nc, multade0	;$+4
	ld	h,d
	ld	l,e
multade0:
	ld b, 7
multade_loop:
	add	hl, hl
	rla
	jr	nc, multade1	;$+4
	add	hl, de
	adc	a, c            ; yes this is actually adc a, 0 but since c is free we set it to zero and so we can save 1 byte and up to 3 T-states per iteration
multade1:   
	djnz	multade_loop
   
   ; now need to put the result back into hl, losing the low fractional bits.
   
	ld l,h
	ld h,a

	pop af
	cp 128
	ret c		; ret if original angle < 128'

	xor a		; fast 6 byte neg of hl. (24 t states!!)
	sub l
	ld l,a
	xor a
	sub h
	ld h,a   
	ret

	; reciprocal 1/x

reciprocal_a:
	; 
	; converts a to (1/a)*256
	;
	; (i.e result is using fixed point 0.8 notation)
	;
	; easiest way to do this I guess is to do
	;
	;	result = 256 * (1/x)
	;
	;	so numerator = 256, denominator = denominator
	;
	;	de = 256
	;	a = denominator
	; and do de/a.	the required number will be in the low byte.
	;
	;	for 8 bit results, a table would probably be useful here.
	; this is why most modern cpu's have hardware maths functions !!

	cp 129
	jr c,recip0
	ld a,1		; for all values of x > 128 , 1/x ~ = 1
	ret
recip0:
	ld hl,reciprocal_table
	add a,l
	ld l,a
	ld a,h
	adc a,0
	ld h,a
	ld a,(hl)
	ret

reciprocal_table:
	defb 0,0,128,85,64,51,42,36,32,28,25,23,21,19,18,17
	defb 16,15,14,13,12,12,11,11,10,10,9,9,9,8,8,8
	defb 8,7,7,7,7,6,6,6,6,6,6,5,5,5,5,5
	defb 5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,4
	defb 4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
	defb 3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2
	defb 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
	defb 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
	defb 2	;,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	


div_a_10:
	; call with a = number
	; approx result stored in a.

	; formula used works okish for 8 bit numbers (rubbish for 16 bit!)
	;x * 26 / 256 = (approx x/10)
	;
	;	26x = 16x + 8x + 2x
	;
	ld h,0
	ld l,a
	add hl,hl		;x2
	add hl,hl		;x4
	add hl,hl		;x8
	ld d,h
	ld e,l			; de = 8x
	add hl,hl		;x16
	add hl,de
	ld d,0
	ld e,a
	add hl,de
	add hl,de
	ld a,h
	ret



	;	----------------------------------------
	;		---- graphics routines ----
	;	----------------------------------------

; Row Table Routines - generate a table of 
; addresses to allow easy working out of
; screen address.

row_table:		equ 65536-8192+6144+768	; row table stored in upper ram, just after the screen buffer.
;	defm 400		; 200 * 2 bytes per entry.

bit_table:			; for drawing pixels with.
	defb	0x80
	defb	0x40
	defb	0x20
	defb	0x10
	defb	0x08
	defb	0x04
	defb	0x02
	defb	0x01


InitRowTable:
	ld bc,192
	ld hl,row_table
	ld de,SCREEN_BUFFER			;16384
IRT0:	
	ld (hl),e
	inc hl
	ld (hl),d
	inc hl
	ex de,hl
	call IncRow
	ex de,hl
	dec c
	jp nz, IRT0
	ret

InitBitTable:
	; inits the bit table to be somewhere in memory so that the following
	; code will work for reading bit positions as fast as possible:
	;	ld a, x coordinate
	;	ld hl,table
	;	and 7
	;	add a,l
	;	ld l,a
	;	ld a,(hl)
	
	ld hl, MEMBOT	;23698		; system variables area, calculator (23698 	MEMBOT 	Calculator's memory area)
	ld b,8
	ld a,0x80
InitBitTable0:
	ld (hl),a
	inc l				; note, only need to inc l as table is within a 256 byte boundry (which is why its here!!)
	srl a
	djnz InitBitTable0
	ret

IncRow:
	; on entry hl = screen address
	; on exit hl = address of next (pixel) row down.
	inc h
	ld a,h
	and 7
	ret nz
	ld a,l
	add a,32
	ld l,a
	ret c
	ld a,h
	sub 8
	ld h,a
	ret

DecRow:
	; on entry hl = screen address
	; on exit hl = address of previous (pixel) row.
	dec h
	ld a,h
	and 7
	cp 7
	ret nz
	ld a,l
	sub 32
	ld l,a
	ret c
	ld a,h
	add a,8
	ld h,a
	ret

IncChr:
	; moves screen address down one entire character (8 pixels)
	; on entry: hl = screen address
	; on exit : hl = screen address, one character below

	ld a,l
	add a,32
	ld l,a
	ret nc
	ld a,h
	add a,8
	ld h,a
	ret

DecChr:
	; moves screen address up one entire character (8 pixels)
	; on entry: hl = screen address
	; on exit : hl = screen address, one character above

	ld a,l
	sub 32
	ld l,a
	ret nc
	ld a,h
	sub 8
	ld h,a
	ret

ScreenToAttr:
	; converts a screen address to an attribute address
	; on entry: de = screen address 
	; on exit : de = attr address

	ld a,d
	rra
	rra
	rra
	and 3
	or 88
	ld d,a
	ret

AttrToScreen:
	; converts an attribute address to screen address
	; on entry: de = attribute address
	; on exit : de = screen address

	ld a,d
	rla
	rla
	rla
	and 24
	or 64
	ld d,a
	ret



; =================================================
; 	Spectrum GFX Library Routines:
;
;	ClearScreen
;	DrawPixel
;	draw vertical line
;	draw horizontal line
;	draw line
; =================================================

ClearScreenBuffer:
	push af
	xor a
	ld hl,SCREEN_BUFFER
	ld de,SCREEN_BUFFER+1
	ld (hl),a
	ld a,192
	jr CLS0

ClearScreen:
	; call with a = attribute byte.
	push af
	xor a
	ld hl,16384
	ld de,16385
	ld (hl),a
	ld a,192
CLS0:
		; repeated ldi instructions apparently faster on real hardware.
		; so dumping a line at a time
	ldi		; 0
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi		; 8
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi		; 16
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	dec a
	jr nz,CLS0
	
	pop af
	ld (hl),a
	ld bc,767
	ldir
	ret
	
DrawScreenBuffer:

	ld hl,ATTR_BUFFER
	ld de,16384+6144
	ld bc,768		; copy attribute buffer *first* to reduce attribute flicker.
	ldir

	ld hl,SCREEN_BUFFER
	ld de,16384
	ld bc,6144
DSB0:
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi
	ldi

	jp pe, DSB0
	
	ret

DrawPixel:
	; call with c = x[0..255], e = y[0..191]
	; do tests to see if pixel is on screen 

	ld a,e
	cp 192
	ret nc
	
	// get row address row to start drawing at
	ld d,0
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.

	ld a,c

;	srl a		;8		; 24 t states, 6 bytes.
;	srl a		;8
;	srl a		;8
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7

	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.
	ex de,hl

;	ld hl,bit_table	; get bit info
;	ld b,0
;	ld a,c
;	and 7
;	ld c,a
;	add hl,bc
;	ld a,(hl)

	ld hl,BITLIST		; BITLIST is a byte aligned table (7 bytes long)
	ld a,c
	and 7
	add a,l
	ld l,a
	ld a,(hl)

	ex de,hl
	or (hl)
	ld (hl),a
	ret

DrawVerticalLine:
	; c = x; d = y1 ; e = y0

	ld a,d		; ensure y0 < y1
	cp e
	jr nc, dvl_0
	ld d,e		; swap y0,y1 if wrong way round
	ld e,a

dvl_0:

	push de

	ld b,e		; store e (faster than doing a push!!)

;	ld hl,bit_table	; get bit info
;	ld d,0
;	ld a,c
;	and 7
;	ld e,a
;	add hl,de
;	ld a,c			; a = x coord
;	ld c,(hl)		; c = bit pattern to draw
	ld hl,BITLIST
	ld a,c
	and 7
	add a,l
	ld l,a
	ld c,(hl)

	ld e,b
	ld d,0
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.
;	srl a
;	srl a
;	srl a
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7


	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.
	
	pop de
	ld a,d
	sub e
	inc a
	ld b,a

	; for now, no optimisation on the main loop, just want it working first.
dvl_1:
	ld a,(hl)
	or c
	ld (hl),a
	call IncRow
	djnz dvl_1
	ret


DrawHorizontalLine:
	; b = x0, c = x1			x0 < x1
	; e = y
	
	; should be reasonably fast as can dump
	;  up to 32,16 or 8 pixels at a time for long lines
	
	ld a,c		; ensure x0 < x1
	cp b
	jr nc, dhl_0
	ld c,b		; swap x0,x1 if wrong way round
	ld b,a

dhl_0:

	; fill left hand side of line with pixels, up to a character
	; boundry - just using draw pixel for now to save memory.

	ld a,b
	and 7
	jr z,dhl_00		; starting on a boundry ??

	push bc
	push de
	ld c,b
	call DrawPixel
	pop de
	pop bc
	inc b
	ld a,c
	cp b
	jr nc, dhl_0
	inc l		; if im right, at this point hl = screen address.
	jr dhl_1

dhl_00:
	ld hl, 0xffff
	push de
	ld d,0
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.
	ld a,b
;	srl a
;	srl a
;	srl a
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7

	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.
	pop de

dhl_1:
	ld d,255

	; some partial loop unrolling to handle runs of 32,16 and 8 pixels
dhl_2:
	ld a,c
	sub b
	cp 32
	jr c,dhl_3
	
	ld (hl),d
	inc l
	ld (hl),d
	inc l
	ld (hl),d
	inc l
	ld (hl),d
	inc l
	ld a,b
	add a,32
	ld b,a
	jr dhl_2

dhl_3:

	ld a,c
	sub b
	cp 16
	jr c, dhl_4

	ld (hl),d
	inc l
	ld (hl),d
	inc l
	ld a,b
	add a,16
	ld b,a
;	jr dhl_3		; do i need this ? after doing blocks of 32 pixels,
					; there up to 31 pixels left.
					;	31 - 16 = 15
					; which cannot be two lots of 16, so no need to loop?
dhl_4:

	ld a,c
	sub b
	jr z, dhl_done
	cp 8
	jr c, dhl_5

	ld (hl),d
	inc l
	ld a,b
	add a,8
	ld b,a
;	jr dhl_4		; by the same logic as before, 15-8 = 7

dhl_5:
	; fill in the remaining pixels.
	push bc
	push de
	ld c,b
	call DrawPixel
	pop de
	pop bc
	inc b
	ld a,b
	cp c
	jr c, dhl_5

dhl_done:
	ret


DrawLine:
	; this is the reason I think i moved from 8 bit to 16 bit programming.
	; there are just not quite enough registers available to make this
	; really efficient or easy to code.
	
	; note: clipping is *# NOT #* done here.
	
	; call with:
	; b = x0
	; c = y0
	; d = x1
	; e = y1

	ld a,e			; ensure line is drawn down the screen so y0 <= y1
	cp c
	jr nc,dl_noswap
	; swap so y0 <= y1
	
	ld e,c
	ld c,a
	ld a,b
	ld b,d
	ld d,a

dl_noswap:

	ld a,e		; calculate dy first to free up c register
	sub c
	ld e,a		; for now, e = dy, as still need d = x1

	push de

	ld hl,bit_table	; get bit info, store in c register
	ld d,0
	ld a,b
	and 7
	ld e,a
	add hl,de
	ld e,c		; move y0 into e for screen address calculation.
	ld c,(hl)	; c = bit position data.

	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.
	ld a,b
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7

	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.

	pop de
	
	; at this point
	; b = x0
	; c = bit data
	; d = x1
	; e = dy
	; hl = screen address

	; to do, calc dx and select slope to draw with.

	ld a,d		; a = x1
	ld d,e		; d = dy
	sub b		; x1 - x0
	ld e,a		; e = dx

	jr c, draw_line_go_left

	; choose between:

	; right dx > dy	draw_line_slope0:
	; right dx < dy	draw_line_slope2:

	ld a,d						; d = dy, e = dx
	sub e						; a = dy - dx
	ld b,e						; b = dx (length of loop)

	jr c, draw_line_slope00
	
	ld b,d						; b = dy (length of loop)
	jr draw_line_slope22

draw_line_go_left:
	
	; choose between 
	; left dx > dy	draw_line_slope1
	; left dx < dy	draw_line_slope3
	
	neg		; dx is -ve as lines go left, so need to get the abs value.
	ld e,a

	ld a,d			; d = dy, e = |dx|
	sub e
	ld b,e
	jr c, draw_line_slope11
	ld b,d
	jr draw_line_slope33

	; for the line drawing loops, registers are used as follows:
	
	; hl = screen position
	; c = bit data to plot with
	; d = dy
	; e = dx
	; a = error adjust 
	; b = loop length.


	; draw line down and to the right dx > dy
	; e = dx, d = dy
draw_line_slope00:
;	push hl
;	ld hl,16384+6144
;	ld a, ink_black + paper_white + bright
;	ld (hl),a
;	pop hl


	ld a,e
	srl a
	
draw_line_slope0:
	ex af,af		; store af
	ld a,(hl)
	or c			; c = bit position to 
	ld (hl),a
	ex af,af
	add a,d			; d = dy
	jr c,dl_noskip0		; If (a+d) > 255 a carry will occur, so (a+d) has to be greater than e
	cp e
	jr c,dl_skip0
dl_noskip0:
	ex af,af
	call IncRow
	ex af,af
	sub e
dl_skip0:
	rrc c
	jr nc, dl_skip1
	inc l
dl_skip1:
	djnz draw_line_slope0
	ret


	; draw line down and to the left dx > dy
draw_line_slope11:
	ld a,e
	srl a
draw_line_slope1:
	ex af,af		; store af
	ld a,(hl)
	or c			; c = bit position to 
	ld (hl),a
	ex af,af
	add a,d			; d = dy
	jr c,dl_noskip1	;	If (a+d) > 255 a carry will occur, so (a+d) has to be greater than e
	cp e
	jr c,dl_skip2
dl_noskip1:
	ex af,af
	call IncRow
	ex af,af
	sub e
dl_skip2:
	rlc c
	jr nc, dl_skip3
	dec l
dl_skip3:
	djnz draw_line_slope1
	ret

	; draw line down and to the right dx < dy

draw_line_slope22:

	ld a,e
	srl a
draw_line_slope2:
	ex af,af		; store af
	ld a,(hl)
	or c			; c = bit position to 
	ld (hl),a
	ex af,af
	add a,e			; e = dx
	jr c,dl_noskip2
	cp d
	jr c,dl_skip4
dl_noskip2:
	sub d
	rrc c
	jr nc, dl_skip4
	inc l
dl_skip4:
	ex af,af
	call IncRow
	ex af,af
	djnz draw_line_slope2
	ret

	; draw line down and to the left dx < dy
draw_line_slope33:
	ld a,d
	srl a
draw_line_slope3:
	ex af,af		; store af
	ld a,(hl)
	or c			; c = bit position to 
	ld (hl),a
	ex af,af
	add a,e			; e = dx
	jr c, dl_noskip3
	cp d
	jr c,dl_skip5
dl_noskip3:
	sub d
	rlc c
	jr nc, dl_skip5
	dec l
dl_skip5:
	ex af,af
	call IncRow
	ex af,af
	djnz draw_line_slope3
	ret

	; ---------------------------------------------
	;		circle drawing stuff
	; ---------------------------------------------



DrawDoublePixel:
	; call with b = x0 c = x1, e = y
	; Draws two pixels per line (for circle drawing stuff)
	; caution ! : this is *much* harder to optimise than it 
	; first appears.

	ld a,e
	cp 192
	ret nc
	
	// get row address row to start drawing at
	ld d,0
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de		; store screen row address.

	ld a,c
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7
	add a,e		; there is never an overflow on each line (very cool)
	ld e,a		; so only have to add offset to e to get screen address!
	
	ld hl,BITLIST
	ld a,c
	and 7
	add a,l
	ld l,a
	ld a,(hl)
	ex de,hl
	or (hl)
	ld (hl),a

	pop de
	ld a,b
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7
	add a,e		; there is never an overflow on each line (very cool)
	ld e,a		; so only have to add offset to e to get screen address!
	
	ld hl,BITLIST
	ld a,b
	and 7
	add a,l
	ld l,a
	ld a,(hl)
	ex de,hl
	or (hl)
	ld (hl),a
	ret

	

_cxcy: defw 0			; circle center coordinates (cx,cy)
_dxdy: defw 0		; dx,dy offset values (ox,oy)
_t1:   defb 0

DrawCircle:
	; b = cy
	; c = cx
	; e = radius
	
	;	jesko's method (from wikipedia):
	; t1 = r / 16
	; x = r
	; y = 0
    ; Repeat Until x < y
    ;   Pixel (x, y) and all symmetric pixels are colored (8 times)
    ;   y = y + 1
    ;   t1 = t1 + y
    ;   t2 = t1 - x
    ;   If t2 >= 0
    ;      t1 = t2
    ;      x = x - 1

	
	ld (_cxcy),bc		; store for later
	ld h,0
	ld l,e
	ld (_dxdy),hl		; x = r, y = 0
	
	ld a,e			;	a = r
	rlca
	rlca
	rlca
	rlca
	and 15
	ld (_t1),a		; t1 = r / 16
	
draw_circle_loop:
	ld hl,(_dxdy)
	ld a,l				; h = y, l = x
	cp h		;sub h
	ret c

	; calls to DrawPixel:
	; call with c = x[0..255], e = y[0..191]

	ld bc,(_cxcy)		; 20 b = cy, c = cx
	ld hl,(_dxdy)	; 16 h = offset y, l = offset x
	ld a,b
	add a,h
	ld e,a			; e = cy + offset y
	ld a,c
	sub l
	ld b,a			; b = cx - offset x
	ld a,c
	add a,l
	ld c,a			; c = cx + offset x
	call DrawDoublePixel

	ld bc,(_cxcy)	; 20 b = cy, c = cx
	ld hl,(_dxdy)	; 16 h = offset y, l = offset x
	ld a,b
	sub h
	ld e,a			; e = cy - offset y
	ld a,c
	sub l
	ld b,a			; b = cx - offset x
	ld a,c
	add a,l
	ld c,a			; c = cx + offset x
	call DrawDoublePixel

		; ----

	ld bc,(_cxcy)		; 20 b = cy, c = cx
	ld hl,(_dxdy)	; 16 h = offset y, l = offset x
	ld a,b
	add a,l
	ld e,a			; e = cy + offset y
	ld a,c
	sub h
	ld b,a			; b = cx - offset x
	ld a,c
	add a,h
	ld c,a			; c = cx + offset x
	call DrawDoublePixel

	ld bc,(_cxcy)	; 20 b = cy, c = cx
	ld hl,(_dxdy)	; 16 h = offset y, l = offset x
	ld a,b
	sub l
	ld e,a			; e = cy - offset y
	ld a,c
	sub h
	ld b,a			; b = cx - offset x
	ld a,c
	add a,h
	ld c,a			; c = cx + offset x
	call DrawDoublePixel

;	ld bc,(_cxcy)		; b = cy, c = cx
;	ld hl,(_dxdy)		; h = offset y, l = offset x
;	ld a,b
;	add a,l
;	ld e,a			; e = cy + offset x
;	ld a,c
;	add a,h
;	ld c,a			; c = cx + offset y
;	call DrawPixel

;	ld bc,(_cxcy)		; b = cy, c = cx
;	ld hl,(_dxdy)		; h = offset y, l = offset x
;	ld a,b
;	add a,l
;	ld e,a			; e = cy + offset x
;	ld a,c
;	sub h
;	ld c,a			; c = cx - offset y
;	call DrawPixel

;	ld bc,(_cxcy)		; b = cy, c = cx
;	ld hl,(_dxdy)		; h = offset y, l = offset x
;	ld a,b
;	sub l
;	ld e,a			; e = cy - offset x
;	ld a,c
;	add a,h
;	ld c,a			; c = cx + offset y
;	call DrawPixel

;	ld bc,(_cxcy)		; b = cy, c = cx
;	ld hl,(_dxdy)		; h = offset y, l = offset x
;	ld a,b
;	sub l
;	ld e,a			; e = cy - offset x
;	ld a,c
;	sub h
;	ld c,a			; c = cx - offset y
;	call DrawPixel

    ;   y = y + 1
    ;   t1 = t1 + y
    ;   t2 = t1 - x
    ;   If t2 >= 0
    ;      t1 = t2
    ;      x = x - 1
    ld hl,(_dxdy)
    inc h
    ld a,(_t1)
    add a,h
    ld b,a			; b = t1
    sub l		; t2 = t1 - x
    jr c, draw_circle_skip0
    ld b,a		; t1 = t2
    dec l
draw_circle_skip0:
	ld a,b
	ld (_t1),a
	ld (_dxdy),hl
	jp draw_circle_loop



	; -----------------------------------------------
	;
	;	Text drawing routines.
	;
	; DrawCh
	; DrawString
	; -----------------------------------------------
	
GetChScreenAddr:
	; b = character column x (0-31)
	; c = character row y (0-23)
	
	; bc destroyed, de unchanged, hl = screen address
	ld a,c
	add a,a			; y * 8
	add a,a
	add a,a
	ld c,a
	ld a,b			; a = column x
	ld b,0
	ld hl,row_table
	add hl,bc
	add hl,bc
	ld c,(hl)
	inc hl
	ld b,(hl)
	ld h,0
	ld l,a
	add hl,bc
	ret

DrawCh:
		; b = character column x (0-31)
		; c = character row y (0-23)
		; a = ch to draw
		; hl = screen address
		; doesn't handle attributes, just character drawing.

	ex af,af	; store ch

	ld a,b		; check coordinates are on screen
	cp 32
	ret nc
	ld a,c
	cp 24
	ret nc

	call GetChScreenAddr	; convert (x,y) to screen address

	; get row address row to start drawing at
	ex af,af

RawDrawCh:
	;	hl = screen address
	;	a = ascii code to draw

	sub 32	; nothing to do for first 32 characters
	ret c

	ex de,hl		; 	4	store screen address

	ld h,0
	ld l,a
	add hl,hl		; fast * 8
	add hl,hl
	add hl,hl

	ld bc, ascii_charset	; 10
	add hl,bc				; 11 t-states

	ex de,hl
	
	ld a,(de)	; loop unrolled.
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	inc h
	inc de
	ld a,(de)
	ld (hl),a
	ret

DrawString:
	; de = string address
	; b = x [0..31], c = y[0..23]
	; a = string length
	ex af,af
	call GetChScreenAddr	; hl = screen address (de unchanged).
	ex af,af
drawstring0:
	push af
	push de
	push hl
	ld a,(de)
	call RawDrawCh
	pop hl
	inc l
	pop de
	inc de
	pop af
	dec a
	jr nz, drawstring0
	
	ret



ascii_charset:
	defb 0x00	;	00000000		; space
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; !
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; "
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x44	;	01000100
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; #
	defb 0x24	;	00100100
	defb 0x7e	;	01111110
	defb 0x24	;	00100100
	defb 0x24	;	00100100
	defb 0x7e	;	01111110
	defb 0x24	;	00100100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; $
	defb 0x18	;	00011000
	defb 0x3e	;	00111110
	defb 0x58	;	01011000
	defb 0x3c	;	00111100
	defb 0x1a	;	00011010
	defb 0x7c	;	01111100
	defb 0x18	;	00011000

	defb 0x00	;	00000000		; %
	defb 0x66	;	01100110
	defb 0x6e	;	01101110
	defb 0x1c	;	00011100
	defb 0x38	;	00111000
	defb 0x76	;	01110110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; &
	defb 0x30	;	00110000
	defb 0x48	;	01001000
	defb 0x30	;	00110000
	defb 0x4a	;	01001010
	defb 0x4c	;	01001100
	defb 0x32	;	00110010
	defb 0x00	;	00000000

	defb 0x30	;	00110000		; '
	defb 0x30	;	00110000
	defb 0x18	;	00011000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; (
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x0c	;	00001100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; )
	defb 0x30	;	00110000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x30	;	00110000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; *
	defb 0x54	;	01010100
	defb 0x38	;	00111000
	defb 0x7c	;	01111100
	defb 0x38	;	00111000
	defb 0x54	;	01010100
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; +
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x7e	;	01111110
	defb 0x7e	;	01111110
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ,
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x30	;	00110000

	defb 0x00	;	00000000		; - (minus)
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x7e	;	01111110
	defb 0x7e	;	01111110
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; . (full stop)
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000

	defb 0x00	;	00000000		; /	(forward slash)
	defb 0x06	;	00000110
	defb 0x0e	;	00001110
	defb 0x1c	;	00011100
	defb 0x38	;	00111000
	defb 0x70	;	01110000
	defb 0x60	;	01100000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 0
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x6e	;	01101110
	defb 0x76	;	01110110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 1
	defb 0x18	;	00011000
	defb 0x38	;	00111000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 2
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x06	;	00000110
	defb 0x1c	;	00011100
	defb 0x30	;	00111000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 3
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x0c	;	00001100
	defb 0x06	;	00000110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 4
	defb 0x60	;	01100000
	defb 0x6c	;	01101100
	defb 0x6c	;	01101100
	defb 0x7e	;	01111110
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 5
	defb 0x7e	;	01111110
	defb 0x60	;	01100000
	defb 0x7c	;	01111100
	defb 0x06	;	00000110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 6
	defb 0x3c	;	00111100
	defb 0x60	;	01100000
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 7
	defb 0x7e	;	01111110
	defb 0x66	;	01100110
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 8
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; 9
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3e	;	00111110
	defb 0x06	;	00000110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; :	(colon)
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ;	(semi-colon)
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x30	;	00110000

	defb 0x00	;	00000000		; <
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x18	;	00011000
	defb 0x0c	;	00001100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; =
	defb 0x7e	;	01111110
	defb 0x7e	;	01111110
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x7e	;	01111110
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; >
	defb 0x30	;	00110000
	defb 0x18	;	00011000
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x30	;	00110000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ?
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x00	;	00000000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; @
	defb 0x3c	;	00111100
	defb 0x42	;	01000010
	defb 0x9a	;	10011010
	defb 0xaa	;	10101010
	defb 0x9c	;	10011100
	defb 0x40	;	01000000
	defb 0x38	;	00111000

	defb 0x00	;	00000000		; A
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7e	;	01111110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; B
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7c	;	01111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; C
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; D
	defb 0x78	;	01111000
	defb 0x6c	;	01101100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x6c	;	01101100
	defb 0x78	;	01111000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; E
	defb 0x7e	;	01111110
	defb 0x60	;	01100000
	defb 0x7c	;	01111100
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; F
	defb 0x7e	;	01111110
	defb 0x60	;	01100000
	defb 0x7c	;	01111100
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; G
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x60	;	01100000
	defb 0x6e	;	01101110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; H
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7e	;	01111110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; I
	defb 0x7e	;	01111110
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; J
	defb 0x06	;	00000110
	defb 0x06	;	00000110
	defb 0x06	;	00000110
	defb 0x06	;	00000110
	defb 0x66	;	01100110
	defb 0x3C	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; K
	defb 0x66	;	01100110
	defb 0x6c	;	01101100
	defb 0x78	;	01111000
	defb 0x78	;	01111000
	defb 0x6c	;	01101100
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; L
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; M
	defb 0xC6	;	11000110
	defb 0xee	;	11101110
	defb 0xfe	;	11111110
	defb 0xD6	;	11010110
	defb 0xc6	;	11000110
	defb 0xc6	;	11000110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; N
	defb 0x66	;	01100110
	defb 0x76	;	01110110
	defb 0x7e	;	01111110
	defb 0x6e	;	01101110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; O
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; P
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7c	;	01111100
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; Q
	defb 0x3C	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x6c	;	01101100
	defb 0x36	;	00110110
	defb 0x03	;	00000011

	defb 0x00	;	00000000		; R
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7c	;	01111100
	defb 0x6c	;	01101100
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; S
	defb 0x3C	;	00111100
	defb 0x60	;	01100000
	defb 0x3C	;	00111100
	defb 0x06	;	00000110
	defb 0x66	;	01100110
	defb 0x3C	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; T
	defb 0x7e	;	01111110
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; U
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3C	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; V
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; W
	defb 0xc6	;	11000110
	defb 0xc6	;	11000110
	defb 0xd6	;	11010110
	defb 0xfe	;	11111110
	defb 0xee	;	11101110
	defb 0xc6	;	11000110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; X
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; Y
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; Z
	defb 0x7e	;	01111110
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x30	;	00110000
	defb 0x60	;	01100000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; [
	defb 0x3c	;	00111100
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; '\'
	defb 0x60	;	01100000
	defb 0x70	;	01110000
	defb 0x38	;	00111000
	defb 0x1c	;	00011100
	defb 0x0e	;	00001110
	defb 0x06	;	00000110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ]
	defb 0x3c	;	00111100
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ^
	defb 0x18	;	00011000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x00	;	01000010
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; _ (underscore ?)
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x7f	;	01111111
	defb 0x7f	;	01111111

	defb 0x00	;	00000000		; `	(funny quote..)
	defb 0x60	;	01100000
	defb 0x60	;	01100000
	defb 0x30	;	00110000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; a
	defb 0x00	;	00000000
	defb 0x3e	;	00111110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3B	;	00111011
	defb 0x00	;	00000000

	defb 0x30	;	00110000		; b
	defb 0x30	;	00110000
	defb 0x3e	;	00111110
	defb 0x33	;	00110011
	defb 0x33	;	00110011
	defb 0x33	;	00110011
	defb 0x6e	;	01101110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; c
	defb 0x00	;	00000000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x60	;	01100000
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x06	;	00000110		; d
	defb 0x06	;	00000110
	defb 0x3e	;	00111110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3B	;	00111011
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; e
	defb 0x00	;	00000000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x7e	;	01111110
	defb 0x60	;	01100000
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x0e	;	00001110		; f
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x7e	;	01111110
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x30	;	00110000

	defb 0x00	;	00000000		; g
	defb 0x00	;	00000000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3e	;	00111110
	defb 0x06	;	00000110
	defb 0x3c	;	00111100

	defb 0x60	;	01100000		; h
	defb 0x60	;	01100000
	defb 0x7c	;	01111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; i
	defb 0x1c	;	00011100
	defb 0x00	;	00000000
	defb 0x1c	;	00011100
	defb 0x0c	;	00001100
	defb 0x0c	;	00001100
	defb 0x3e	;	00111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; j
	defb 0x06	;	00000110
	defb 0x00	;	00000000
	defb 0x06	;	00000110
	defb 0x06	;	00000110
	defb 0x06	;	00000110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100

	defb 0x60	;	01100000		; k
	defb 0x6c	;	01101100
	defb 0x78	;	01111000
	defb 0x70	;	01110000
	defb 0x78	;	01111000
	defb 0x6c	;	01101100
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x18	;	00011000		; l
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x18	;	00011000
	defb 0x0e	;	00001110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; m
	defb 0x00	;	00000000
	defb 0x36	;	00110110
	defb 0x7f	;	01111111
	defb 0x6B	;	01101011
	defb 0x63	;	01100011
	defb 0x63	;	01100011
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; n
	defb 0x00	;	00000000
	defb 0xDC	;	11011100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; o
	defb 0x00	;	00000000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; p
	defb 0x00	;	00000000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x7c	;	01111100
	defb 0x60	;	01100000
	defb 0x60	;	01100000

	defb 0x00	;	00000000		; q
	defb 0x00	;	00000000
	defb 0x1e	;	00011110
	defb 0x33	;	00110011
	defb 0x33	;	00110011
	defb 0x1f	;	00011111
	defb 0x03	;	00000011
	defb 0x03	;	00000011

	defb 0x00	;	00000000		; r
	defb 0x00	;	00000000
	defb 0x6e	;	01101110
	defb 0x33	;	00110011
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; s
	defb 0x00	;	00000000
	defb 0x1e	;	00011110
	defb 0x30	;	00110000
	defb 0x1e	;	00011110
	defb 0x03	;	00000011
	defb 0x3e	;	00111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; t
	defb 0x30	;	00110000
	defb 0x7c	;	01111100
	defb 0x30	;	00110000
	defb 0x30	;	00110000
	defb 0x36	;	00110110
	defb 0x1c	;	00011100
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; u
	defb 0x00	;	00000000
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3b	;	00111011
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; v
	defb 0x00	;	00000000
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x18	;	00011000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; w
	defb 0x00	;	00000000
	defb 0x63	;	01100011
	defb 0x63	;	01100011
	defb 0x6b	;	01101011
	defb 0x7f	;	01111111
	defb 0x36	;	00110110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; x
	defb 0x00	;	00000000
	defb 0x66	;	01100110
	defb 0x3c	;	00111100
	defb 0x18	;	00011000
	defb 0x3c	;	00111100
	defb 0x66	;	01100110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; y
	defb 0x00	;	00000000
	defb 0x33	;	00110011
	defb 0x33	;	00110011
	defb 0x33	;	00110011
	defb 0x1e	;	00011110
	defb 0x0c	;	00001100
	defb 0x38	;	00111000

	defb 0x00	;	00000000		; z
	defb 0x00	;	00000000
	defb 0x7e	;	01111110
	defb 0x0c	;	00001100
	defb 0x18	;	00011000
	defb 0x30	;	00110000
	defb 0x7e	;	01111110
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; {
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00011000		; |
	defb 0x00	;	00011000
	defb 0x00	;	00011000
	defb 0x00	;	00011000
	defb 0x00	;	00011000
	defb 0x00	;	00011000
	defb 0x00	;	00011000
	defb 0x00	;	00011000

	defb 0x00	;	00000000		; }
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000

	defb 0x00	;	00000000		; ~	(squiggle!)
	defb 0x36	;	00110110
	defb 0x6c	;	01101100
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000
	defb 0x00	;	00000000


; --------------------------------------
; some miscellaneous routines:
; --------------------------------------

reverse_table:
	defb 0,128,64,192,32,160,96,224,16,144,80,208,48,176,112,240
	defb 8,136,72,200,40,168,104,232,24,152,88,216,56,184,120,248
	defb 4,132,68,196,36,164,100,228,20,148,84,212,52,180,116,244
	defb 12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252
	defb 2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242
	defb 10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250
	defb 6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246
	defb 14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254
	defb 1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241
	defb 9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249
	defb 5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245
	defb 13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253
	defb 3,131,67,195,35,163,99,227,19,147,83,211,51,179,115,243
	defb 11,139,75,203,43,171,107,235,27,155,91,219,59,187,123,251
	defb 7,135,71,199,39,167,103,231,23,151,87,215,55,183,119,247
	defb 15,143,79,207,47,175,111,239,31,159,95,223,63,191,127,255

reverse_byte_bits:
	; reverses the bits in a byte
	; call with a = byte to reverse

	push hl					; 11			
	ld hl, reverse_table	; 10
	add a,l					;  4
	ld l,a					;  4
	ld a,h					;  4
	adc a,0					;  7
	ld h,a					;  4
	ld a,(hl)				;  7
	pop hl					; 10
	ret						; 10
				; total :     71 T states 

;reverse_word_bits:
	; de = word to reverse

;	ld a,d
;	call reverse_byte_bits
;	ld d,a

;	ld a,e
;	call reverse_byte_bits
;	ld e,a
	
;	ld a,d
;	ld d,e
;	ld e,a
;	ret

reverse_data_block:
	; hl = address of block
	; b = length of block
	; reverses the bits of the data in place.
	
	ld a,b
	cp 1
	jr z, rvblock2
	
rvblock00:
	push hl
	ld d,0
	ld e,b
	add hl,de
	dec hl
	ex de,hl	; de = address of last byte of block
	pop hl

	ld a,b
	push af
	rra			; only need loop to be half total block length.
	ld b,a

rvblock0:
	ld a,(hl)
	call reverse_byte_bits
	ld c,a
	ld a,(de)
	call reverse_byte_bits
	ld (hl),a
	ld a,c
	ld (de),a
	inc hl
	dec de
	djnz rvblock0
rvblock1:
	pop af
	and 1
	ret z
rvblock2:
	ld a,(hl)				; do odd end byte.
	call reverse_byte_bits
	ld (hl),a
	ret

	; -----------------------------------------------------
	; converts a 16 bit numeric value to an ascii string.
	; (not very fast!)
	; -----------------------------------------------------
	
NumToAsciiString:
	; de = string address
	; hl = number
	
	ld b,0
NumString0:
	push de
	push hl
	ld d,0
	ld e,b
	ld hl,NumStringTable
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	
	pop hl
	xor a
NumString1:
	inc a
	sbc hl,de
	jr nc,NumString1
	add hl,de
	dec a
	add a,48
	
	pop de
	ld (de),a
	inc de
	
	inc b
	ld a,b
	cp 5
	jr nz, NumString0
	ret

NumStringTable:
defw 10000,1000,100,10,1


	; ------------------------------------
	;
	;		---- Sprite Routines ----
	;
	; ------------------------------------

drawsprite_screen_addr:	defw 0
drawsprite_data:	defw 0
drawsprite_rotjmp:	defw 0

_DrawSpriteSetup:
	; b = height
	; c = x
	; e = y
	; hl = sprite data, 8 pixels pixels per row (1 byte)
	; a = jump table offset (0,16 or 32)

	ld (drawsprite_data),hl		; temporary store (not wasting time trying to shoehorn into a register!)
	
	ld d,0
	push de

	ld hl,sprite_rotate_jmp_table	; calc jump table address from offset
	ld e,a
	add hl,de
	ld a,c		; get jump address within table
	and 7
	add a,a
	ld e,a
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	ld (drawsprite_rotjmp),de

	pop de
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.
	ld a,c
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7
	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.
	ld (drawsprite_screen_addr),hl
	ret

	; ---- 8 pixel sprite drawing routine

DrawSprite8:
	; draws an 8 pixel wide 'sprite' to the screen.
	; graphics are rotated into place as required.
	; b = height
	; c = x
	; e = y
	; hl = sprite data, 8 pixels pixels per row (1 byte)

	xor a
	call _DrawSpriteSetup

loop_ds8:

	ld hl,(drawsprite_data)
	ld a,(hl)
	inc hl
	ld (drawsprite_data),hl
	ld h,0
	ld l,a

		; do rotates h << l
		
	; note only need a maximum of 7 rotates, as 8 rotates 
	; just moves the data onto the next byte.

	; doing this weird kind of jump, as cant do jp (hl).
	xor a
	ld de,(drawsprite_rotjmp)
	push de
	ret

spr8_rot8:
	ld a,h
	ld h,l
	ld l,0
	jr spr8_rot0

spr8_rot7:
	add hl,hl
spr8_rot6:
	add hl,hl
spr8_rot5:
	add hl,hl
spr8_rot4:
	add hl,hl
spr8_rot3:
	add hl,hl
spr8_rot2:
	add hl,hl
spr8_rot1:
	add hl,hl
spr8_rot0:

	ex de,hl	; de = hl
	
	ld hl,(drawsprite_screen_addr)

	ld a,d	; or 2 bytes to the screen area
	or (hl)
	ld (hl),a
	inc l

	ld a,e
	or (hl)
	ld (hl),a
	
	dec l

	call IncRow
	
	ld (drawsprite_screen_addr),hl

	djnz loop_ds8
	ret
	
	; ---- 16 pixel sprite drawing routine

DrawSprite16:
	; draws a 16 pixel wide 'sprite' to the screen.
	; graphics are rotated into place as required.
	; b = height
	; c = x
	; e = y
	; hl = sprite data, 16 pixels pixels per row (2 bytes)
	
	ld a,16
	call _DrawSpriteSetup

loop_ds16:

	ld hl,(drawsprite_data)
	ld d,(hl)
	inc hl
	ld e,(hl)
	inc hl
	ld (drawsprite_data),hl

	ex de,hl

		; do rotates a << c << h << l
		
	; note only need a maximum of 7 rotates, as 8 rotates 
	; just moves the data onto the next byte.

	; doing this weird kind of jump, as cant do jp (hl).
	xor a
	ld de,(drawsprite_rotjmp)
	push de
	ret

spr16_rot8:
	ld a,h
	ld h,l
	ld l,0
	jr spr16_rot0

spr16_rot7:
	add hl,hl
	rla
spr16_rot6:
	add hl,hl
	rla
spr16_rot5:
	add hl,hl
	rla
spr16_rot4:
	add hl,hl
	rla
spr16_rot3:
	add hl,hl
	rla
spr16_rot2:
	add hl,hl
	rla
spr16_rot1:
	add hl,hl
	rla
spr16_rot0:

	ex de,hl	; de = hl
	
	ld hl,(drawsprite_screen_addr)

	or (hl)			; or 4 bytes to the screen area
	ld (hl),a
	inc l

	ld a,d
	or (hl)
	ld (hl),a
	inc l

	ld a,e
	or (hl)
	ld (hl),a
	
	dec l
	dec l

	call IncRow
	
	ld (drawsprite_screen_addr),hl

	djnz loop_ds16
	ret


	; ---- BIG 24 pixel sprite drawing routine ----


DrawSprite24:
	; draws a 24 pixel wide 'sprite' to the screen.
	; graphics are rotated into place as required.
	; b = height
	; c = x
	; e = y
	; hl = sprite data, 24 pixels per row (3 bytes)

	ld a,32
	call _DrawSpriteSetup

loop_ds24:

	ld hl,(drawsprite_data)
	ld c,(hl)	; get data into cde
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	inc hl
	ld (drawsprite_data),hl

	ex de,hl

		; do rotates a << c << h << l
		
	; note only need a maximum of 7 rotates, as 8 rotates 
	; just moves the data onto the next byte.

	; doing this weird kind of jump, as cant do jp (hl).
	xor a
	ld de,(drawsprite_rotjmp)
	push de
	ret

spr24_rot8:
	ld a,c
	ld c,h
	ld h,l
	ld l,0
	jr spr24_rot0

spr24_rot7:
	add hl,hl
	rl c
	rla
spr24_rot6:
	add hl,hl
	rl c
	rla
spr24_rot5:
	add hl,hl
	rl c
	rla
spr24_rot4:
	add hl,hl
	rl c
	rla
spr24_rot3:
	add hl,hl
	rl c
	rla
spr24_rot2:
	add hl,hl
	rl c
	rla
spr24_rot1:
	add hl,hl
	rl c
	rla
spr24_rot0:

	ex de,hl	; de = hl
	
	ld hl,(drawsprite_screen_addr)

	or (hl)			; or 4 bytes to the screen area
	ld (hl),a
	inc l

	ld a,c
	or (hl)
	ld (hl),a
	inc l

	ld a,d
	or (hl)
	ld (hl),a
	inc l

	ld a,e
	or (hl)
	ld (hl),a
	
	dec l
	dec l
	dec l

	call IncRow
	
	ld (drawsprite_screen_addr),hl

	djnz loop_ds24
	ret

sprite_rotate_jmp_table:		; 16 bytes per table.
spr8_rotate_jmp_table:
	defw	spr8_rot8, spr8_rot7, spr8_rot6, spr8_rot5
	defw	spr8_rot4, spr8_rot3, spr8_rot2, spr8_rot1
spr16_rotate_jmp_table:
	defw	spr16_rot8, spr16_rot7, spr16_rot6, spr16_rot5
	defw	spr16_rot4, spr16_rot3, spr16_rot2, spr16_rot1
spr24_jmp_table:
	defw	spr24_rot8, spr24_rot7, spr24_rot6, spr24_rot5
	defw	spr24_rot4, spr24_rot3, spr24_rot2, spr24_rot1
	


testsprite24:
	defb 0xff, 0xff, 0xff
	defb 0x80, 0x00, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01

	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01

	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x3C, 0x01
	defb 0x80, 0x00, 0x01
	defb 0xff, 0xff, 0xff
	

testsprite16:
	defw	0x4002	;// 00000010 01000000
	defw	0x2007	;// 00000111 00100000
	defw	0x900f	;// 00001111 10010000
	defw	0x900f	;// 00001111 10010000
	defw	0x0000	;// 00000000 00000000
	defw	0xfa7f	;// 01111111 11111010
	defw	0xfdff	;// 11111111 11111101
	defw	0xfdff	;// 11111111 11111101
	defw	0xfa7f	;// 01111111 11111010
	defw	0x0000	;// 00000000 00000000
	defw	0x7007	;// 00000111 11100000
	defw	0x1008	;// 00001000 00010000
	defw	0x8811	;// 00010001 10001000
	defw	0x0420	;// 00100000 00000100
	defw	0x03c0	;// 11000000 00000011
	defw	0x03c0	;// 11000000 00000011
	
testsprite8:
	defb 0x3c			; 00111100
	defb 0x42			; 01000010
	defb 0x91			; 10010001
	defb 0x9d			; 10011101
	defb 0xb9			; 10111001
	defb 0x89			; 10001001
	defb 0x42			; 01000010
	defb 0x3c			; 00111100



	; ===========================================
	;		Keyboard Reading Routines.
	; ===========================================

GetKey:
	; NOTE: returns the ascii keycode for a SINGLE keypress.
	; carry set if no key pressed,
	; otherwise returns ascii key code in A
	; ** under construction **

	ld e,0
	ld hl,in_port_table
	ld b,8
GK0:	ld a,(hl)
	in a,(254)
	cpl
	and 31
	ld c,a
	jp nz,gotkey
	ld a,e
	add a,5
	ld e,a
	inc hl

	dec b
	jp nz,GK0
	scf
	ret
gotkey:
	ld hl,key_table
	ld d,0
	add hl,de
GK1:
	rra
	jp c, GK2
	inc hl
	jp GK1
GK2:
	ld a,(hl)
	and a
	ret

in_port_table:
	defb 0xfe
	defb 0xfd
	defb 0xfb
	defb 0xf7
	defb 0xef
	defb 0xdf
	defb 0xbf
	defb 0x7f

key_table:
	defs "*ZXCVASDFGQWERT1234509876POIUY+LKJH;#MNB"
key_pressed_table:
	defb 0,0,0,0,0,0,0,0			; one byte per port

	
ReadKeyboard:
	ld hl,in_port_table
	ld de,key_pressed_table
	ld b,8
rk0:
	ld a,(hl)
	in a,(254)
	cpl
	and 31
	ld (de),a
	inc hl
	inc de
	djnz rk0
	ret
	
IsKeyPressed:
	; call with a = key code constant.
	; keycode encoding is as follows : 
	
	; a :
	;	128 64 32  | 16 8 4 2 1 
	; <group 0-7>  | <bit mask>
	
	; returns z = not pressed, nz = pressed.
	
	ld b,a		; b = bit mask
	
	rlca
	rlca
	rlca
	and 7	; a = group. [0..7]
	ld hl,key_pressed_table
	ld d,0
	ld e,a
	add hl,de
	ld a,(hl)
	and b
	and 31
	ret



 ; 27/11/2023 8:30
;KEY_CAPS: equ	(0*32)+1	; *ZXCV
;KEY_Z:	equ	(0*32)+2
;KEY_X:	equ	(0*32)+4
;KEY_C:	equ	(0*32)+8
;KEY_V:	equ	(0*32)+16

;KEY_A:	equ	(1*32)+1		; ASDFG
;KEY_S:	equ	(1*32)+2
;KEY_D:	equ	(1*32)+4
;KEY_F:	equ	(1*326)+8
;KEY_G:	equ	(1*32)+16
	
;KEY_Q:	equ	(2*32)+1		; QWERT
;KEY_W:	equ	(2*32)+2
;KEY_E:	equ	(2*32)+4
;KEY_R:	equ	(2*32)+8
;KEY_T:	equ	(2*32)+16

;KEY_1:	equ	(3*32)+1		; 12345
;KEY_2:	equ	(3*32)+2
;KEY_3:	equ	(3*32)+4
;KEY_4:	equ	(3*32)+8
;KEY_5:	equ	(3*32)+16

;KEY_0:	equ	(4*32)+1		; 09876
;KEY_9:	equ	(4*32)+2
;KEY_8:	equ	(4*32)+4
;KEY_7:	equ	(4*32)+8
;KEY_6:	equ	(4*32)+16

;KEY_P:	equ	(5*32)+1		; POIUY
;KEY_O:	equ	(5*32)+2
;KEY_I:	equ	(5*32)+4
;KEY_U:	equ	(5*32)+8
;KEY_Y:	equ	(5*32)+16

;KEY_ENTER:	equ	(6*32)+1		; +LKJH
;KEY_L:	equ	(6*32)+2
;KEY_K:	equ	(6*32)+4
;KEY_J:	equ	(6*32)+8
;KEY_H:	equ	(6*32)+16

;KEY_SPC:	equ	(7*32)+1		; ;#MNB
;KEY_SS:	equ	(7*32)+2
;KEY_M:	equ	(7*32)+4
;KEY_N:	equ	(7*32)+8
;KEY_B:	equ	(7*32)+16




	; -------------------------------------
	; 		Wait for Vertical Blank
	; -------------------------------------
	
	// Note : this version relies on the spectrum interrupts
	// being available, so no calls to 'di' please !

WaitVBL:
	ld hl,23672
	ld a,(hl)

waitvbl0:			; could expand this to do some calls, rather than just sit and wait.
	cp (hl)
	jp z, waitvbl0
	ret
	
WaitVBL2:		; halt just does nothing other than wait for an interrupt.
	halt
	ret

	; ---------------------------------------
	;	Random Number Generator 
	; ---------------------------------------
	
	; its VERY hard to get a good random number generator so I've used
	; a tried and tested one from the internet
	; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
	
	; hl = random number generated

RandomHL:
						;seed1_0=$+1
    ld hl,(seed1_0)		;12345
						;seed1_1=$+1
    ld de,(seed1_1)		;6789
    ld b,h
    ld c,l
    add hl,hl
    rl e
    rl d
    add hl,hl
    rl e
    rl d
    inc l
    add hl,bc
    ld (seed1_0),hl
    ld hl,(seed1_1)
    adc hl,de
    ld (seed1_1),hl
    ex de,hl
						;seed2_0=$+1
    ld hl,(seed2_0)		;9876
						;seed2_1=$+1
    ld bc,(seed2_1)		;54321
    add hl,hl
    rl c
    rl b
    ld (seed2_1),bc
    sbc a,a
    and 0xC5			;%11000101
    xor l
    ld l,a
    ld (seed2_0),hl
    ex de,hl
    add hl,bc
    ret

seed1_0:	defw	12345
seed1_1:	defw	6789
seed2_0:	defw	9876
seed2_1:	defw	54321


	; ----------------------------------------------
	;	Simple Collision Detection
	; ----------------------------------------------

	; possible combinations
	;	x0----x1	x2----x3
	;	x2----x3	x0----x1
	
	;   x0------x1
	;		x2-------x3
	
	;	x2-------x3
	;		x0-------x1
	
	;	x0----------x1
	;		x2--x3
	
	;	x2-----------x3
	;		x0--x1
	
	;	only two cases to check where lines do not overlap.
	;
	;
	;
	
	; b = x0	(x0 --> x1 ) coordinates of first box
	; c = x1
	; d = x2
	; e = x3
	
	; x0 < x1 and x2 < x3
	
	; if (x1 < x2)	no collision
	; if (x3 < x0)	no collision

CollisionCheck:
	; returns no carry if collision occurs, carry otherwise
	ld a,d
	sub c			; x1 - x2
	ret nc
	ld a,b
	sub e			; x0 - x3
	ret	

	; ---------------- some vector stuff -------------
	;
	;	Vectors are stored as 3 32 bit values each.
	;	each vector has 3 values (x,y,z)
	;
	;	note : vector stuff under construction, requires testing
	;
	; ------------------------------------------------

vector_add:
	; de = address vector 1
	; hl = address vector 2
	; bc = address of result
	; x' = x1 + x2; y' = y1 + y2 ; z' = z1 + z2
	
	ld a,12
vector_add_0:
	push af
	ld a,(de)
	add a,(hl)
	ld (bc),a
	inc hl
	inc de
	inc bc
	ld a,(de)
	adc a,(hl)
	ld (bc),a
	inc hl
	inc de
	inc bc
	ld a,(de)
	adc a,(hl)
	ld (bc),a
	inc hl
	inc de
	inc bc
	ld a,(de)
	adc a,(hl)
	ld (bc),a
	pop af
	dec a
	jr nz, vector_add_0
	ret
	
vector_scale:
	;	hl = addres vector to scale
	;	bc.de = scale amount.

	ld (mul_al),de		; ah doesnt change so only have to store this
	ld (mul_ah),bc		; here once.

	ld b,3
vector_scale_0:
	push bc
	push hl

	ld e,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld b,(hl)

	ld (mul_bl),de
	ld (mul_bh),bc

	call mul_32
	
	pop hl
	ld de,(mul_rl)
	ld bc,(mul_rh)
	ld (hl),e
	inc hl
	ld (hl),d
	inc hl
	ld (hl),c
	inc hl
	ld (hl),b
	inc hl
	pop bc
	djnz vector_scale_0
	ret

	


CrossProduct:
		; de = pointer to vector 1
		; hl = pointer to vector 2
		; bc = pointer to result buffer

	;dp = (x0*x1)+(y0*y1)+(z0*z1)
	

;	push bc				; store pointer to result buffer.
;	ld bc,0
;	ld (cpmul_tl),bc
;	ld (cpmul_th),bc

;	ld b,3

;cp_lp0:
;	push bc

	; do de * hl, store in result buffer.
	
;	ld c,(hl)			; load 32 bit value into a
;	inc hl
;	ld b,(hl)
;	inc hl
;	ld (cpmul_al),bc
;	ld c,(hl)
;	inc hl
;	ld b,(hl)
;	inc hl
;	ld (cpmul_ah),bc
;	inc hl
	
;	ex de,hl

;	ld c,(hl)			; load 32 bit value into b
;	inc hl
;	ld b,(hl)
;	inc hl
;	ld (cpmul_bl),bc
;	ld c,(hl)
;	inc hl
;	ld b,(hl)
;	inc hl
;	ld (cpmul_bh),bc
;	inc hl
	
;	ex de,hl

;	push hl
;	push de
	
;	call cpmul

;	ld hl,(cpmul_tl)		; add to running total.
;	ld de,(cpmul_rl)
;	add hl,de
;	ld (cpmul_tl),hl
;	ld hl,(cpmul_th)
;	ld de,(cpmul_rh)
;	adc hl,de
;	ld (cpmul_th),hl
	
;	pop de
;	pop hl
;	djnz cp_lp0
	
;	pop hl				; hl = result buffer
;	ld de,(cpmul_tl)
;	ld (hl),e
;	inc hl
;	ld (hl),d
;	inc hl
;	ld de,(cpmul_th)
;	ld (hl),e
;	inc hl
;	ld (hl),d
;	ret

	; ------------------------------------------------------
	;
	;	Decompression routines.
	;
	; ------------------------------------------------------
	
rle_decode:
	; really, really simple rle_decoding
	; data is stored in the following format
	;
	;	 bit 7	 bits 0-6
	;	+-----+-----------+
	;	|  T  |  NNNNNNN  |
	;	+-----+-----------+
	;
	;	T = 0, NNNNNN = number of bytes of data that follow this byte
	;	T = 1, NNNNNN = the next byte is to be repeated NNNNNN times.
	;
	;	T = 0, NNNNNN = 0, (i.e zero) terminates the decoding.


	; 	hl = source data address
	;	de = destination address
	
rle_decode_loop:
	ld a,(hl)
	and a
	ret z							; terminate if a zero is found.
	bit 7,a							; test T bit
	jr z,rle_decode_data_block
	
	; run of repeat data
	and 127
	ld b,a
	inc hl
	ld a,(hl)
	inc hl
rle_decode_0:
	ld (de),a
	inc de
	djnz rle_decode_0
	jr rle_decode_loop

rle_decode_data_block:
	and 127
	ld b,a
	inc hl
rle_decode_1:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz rle_decode_1
	jr rle_decode_loop


		; -----------------------------------------------------
		;
		;		---- distance point to a line ----
		;
		;	uses an 8x8 multiply routine and 
		;	a square root routine.
		;
		;	 Note : longer lines = more bits of precision needed.
		;	Lines of length 128 or less should keep the arithmetic
		;	with 16 bit range.
		;
		; -----------------------------------------------------
		; bc = point coordinates(xo,yo)
		; de = line coordinates (x1,y1)
		; hl = line coordinates (x2,y2)




;calc_line_length:
		; b = x0 [0..255]
		; c = y0 [0..191]
		; d = x1 [0..255]
		; e = y1 [0..191]

;	ld a,d
;	sub b
;	jr c, cll0
;	neg
;cll0:
;	ld b,a		; b = |dx|

;	ld a,e
;	sub c
;	jr c, cll2
;	neg
;cll2:
;	ld c,a		; c = |dy|
	
;	ld d,b
;	ld e,b
;	call mul_8x8	; hl = |dx|^2
;	push hl
	
;	ld d,c
;	ld e,c
;	call mul_8x8
;	ex de,hl		; de = |dy|^2

;	pop de
;	xor a
;	add hl,de		
;	adc a,a			; square of line length stored in ahl (24 bit result!!)

	ld d,0
	ld e,a
	call sqrt_32
	
	; hl should be the square root.



	; from https://map.grauw.nl/articles/mult_div_shifts.php

	; in : hl = value
	; out : d = result (rounded down)

;Sqrt_16:
;    ld de,#0040
;    ld a,l
;   ld l,h
;    ld h,d
;    or a
;    ld b,8
;Sqrt_16_Loop:
;    sbc hl,de
;    jr nc,Sqrt_16_Skip
;    add hl,de
;Sqrt_16_Skip:
;    ccf
;    rl d
;    add a,a
;    adc hl,hl
;    add a,a
;    adc hl,hl
;    djnz Sqrt_16_Loop
;    ret
    
	; also see:
    ; from wikipedia https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_.28base_2.29
    
;x2_x1:	defb 0
;y1_y0:	defb 0
;x1_x0:	defb 0
;y2_y1:	defb 0

;x2_x1_y1_y0:	defw 0		;	(x2-x1)(y1-y0)		; result is 16 bits max.
;x1_x0_y2_y1:	defw 0		; 	(x1-x0)(y2-y1)

;x2_x1_sqrd:	defw 0
;y2_y1_sqrd:	defw 0

;dpl_numerator:	defb 0		; 24 bit numerator.
;				defw 0

;dpl_denominator: defw 0

	;distance_point_line:
;distance_point_line:

	; formula (from wikipedia)
	;
	;	distance = 	  | (x2-x1)(y1-y0) - (x1-x0)(y2-y1) |
	;				--------------------------------------
	;				 sqrt { (x2-x1)^2 + (y2-y1)^2 }
	;
	;
	;	there is a problem with this equation -> the numerator
	; 	(and possibly the denominator) might exceed 16 bit precision.
	;	running tests on the screen show that if the line length is
	;	approximately 128 pixels long or less, the equations should 
	; 	still work, without having to resort to 32 bit arithmetic.

	;
	;	worth noting maybe ??
	;
	;		sqrt (n) =	sqrt (n*256)/16
	;
	;	sqrt(n*256) gives an extra 4 bits (.bbbb) of the answer.
	;
	;	n*16 gives 2 bits of answer.(0.bb)
	;
	;	n*4 gives 1 bit of answer. (0.b)
	;
	;
	;	also worth noting, the denominator is simply the length of
	;	the line itself - could this be precalculated ???
	;
	;

	;b = xo, c = y0		; point coordinates
	;d = x1, e = y1		; line end 1
	;h = x2, l = y2		; line end 2

;	ld a,h
;	sub d
;	ld (x2_x1),a

;	ld a,e
;	sub c
;	ld (y1_y0),a

;	ld a,d
;	sub b
;	ld (x1_x0),a

;	ld a,l
;	sub e
;	ld (y2_y1),a

;	ld de,(x2_x1)			; e = x2_x1, d = y1_y0
;	call mul_8x8			; do d * e
;	ld (x2_x1_y1_y0),hl		; store result

;	ld de,(x1_x0)			; e = x1_x0, d = y2_y1
;	call mul_8x8			; do d * e
;	ld (x1_x0_y2_y1),hl		; store result.


;	ld de,(x2_x1)			; e = x2_x1
;	ld d,e					; d = e
;	call mul_8x8		
;	ld (x2_x1_sqrd),hl		; store result (x2_x1)^2

;	ld de,(y2_y1)			; e = y2_y1
;	ld d,e					; d = e
;	call mul_8x8
;	ld (y2_y1_sqrd),hl		; store result (y2_y1)^2
	
	; now calculate the numerator

;	ld hl,(x2_x1_y1_y0)
;	ld de,(x1_x0_y2_y1)
;	or a
;	sbc hl,de				; hl = (x2-x1)(y1-y0) - (x1-x0)(y2-y1)
;	bit 7,h
;	jr z, dtol_abs

;	xor a			; neg hl.. faster than :
;	sub l			;	ld de,0
;	ld l,a			;	ex de,hl
;	sbc a,a			;	or a
;	sub h			;	sbc hl,de
;	ld h,a			;

;dtol_abs:
;	ld (dpl_numerator),hl		; store numerator

;	ld a,h
;	or l
;	ret z			; early out if numerator = 0 (point on line)


	; now need to calculate the denominator

;	ld hl,(x2_x1_sqrd)
;	ld de,(y2_y1_sqrd)
;	add hl,de

;	ld a,h
;	or l
;	ret z			;	if denominator = 0, some error has occurred as should not get here.

	; need to get sqrt (denominator), but want some fractional bits of
	; accuracy.

;	call Sqrt_16


	; 


	; ------------------------------------------------------
	;
	;	Fast Memory Copy ?? (using the stack)
	;
	;
	;	hl = source
	;	de = dest
	; ------------------------------------------------------

tmp_sp:	defw 0

fast_copy_16_bytes:
	di

	;ldi 	; 16 t states per byte

			;	push ix = 15 t-states, push qq = 11 t states.
			;	pop qq = 10 t states	pop ix = 14 t-states.
			;	ld sp,hl = 6 t states.

	; code below copies 16 bytes, abuses the stack, and has self
	; modifying code. 

;	ld (next_pop+1),hl		; 20
;	ld (next_push+1),de		; 20

;next_pop:
;	ld sp,0			; 10
;	pop bc		; 10
;	pop de		; 10
;	pop hl		; 10
;	pop af		; 10
;	exx			; 4
;	ex af,af	; 4
;	pop bc		; 10
;	pop de		; 10
;	pop hl		; 10
;	pop af		; 10
;	ld (next_pop+1),sp	; 20		; 118
;next_push:
;	ld sp,0		; 10
;	push af		; 11
;	push hl		; 11
;	push de		; 11
;	push bc		; 11
;	exx			; 4
;	ex af,af	; 4
;	push af		; 11
;	push hl		; 11
;	push de		; 11
;	push bc		; 11
;	ld (next_push+1),sp	; 20

	; 244 t states for the above monstrosity.
	
	; 16 ldi's = 16 x 16 = 256.


	; -----------------------------------------------------------

	;	quadratic bezier curve point calculation (v2.0)
	;
	;	B(t) = P1 + (1-t)^2(P0-P1) + t^2(P2-P1)

	;	t values are stored in 1/16th increments * 256

	;	in:
	;
	;	hl = address of curve data, stored 1 byte per coordinate
	;	a = t value [0..15]
	;	defb x0,y0,x1,y1,x2,y2
	
	;	out
	;	h = px,	l = py
	;

	; OMT = table of values for t from 0 to 1 such that
	;	OMT[k] = Math.floor (0.5 + (256 * (1 - t) * ( 1 - t)))
	; TSQRD[k] = Math.floor (0.5 + (256 * t * t))
	;
	; 0.5 to round up numbers that are very close to 1

	; original attempt using 8 bit values failed, as the equations
	; just overflow too often, and negative values conflict with +ve.

	; -----------------------------------------------------------


OMT:	defb  255, 224, 195, 168, 143, 121, 100, 81, 64, 49, 36, 25, 16, 9, 4, 1,0

TSQRD:	defb 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 143, 168, 195, 224, 255

bezier_t:	defb 0

p0x_p1x:	defw 0
p0y_p1y:	defw 0
p2x_p1x:	defw 0
p2y_p1y:	defw 0
bezier_y0:	defw 0

bezier_y1:	defb 0
bezier_x1:	defb 0

bezier_tmp_0:	defw 0
bezier_tmp_1:	defw 0
bezier_tmp_2:	defw 0
bezier_tmp_3:	defw 0

get_quadratic_bezier_point:
	ld (bezier_t),a
	
	ld e,(hl)			; e = x0
	inc hl
	ld a,(hl)			; a = y0
	inc hl
	ld b,(hl)			; b = x1
	inc hl
	ld c,(hl)			; c = y1

	ld (bezier_y1),bc

	inc hl
	push hl				; (hl) = x2
	ld h,0
	ld d,h
	ld l,b
	ex de,hl			; hl = x0, de = x1
	and a
	sbc hl,de			; x0 - x1
	ld (p0x_p1x),hl

	ld h,0
	ld d,h
	ld l,a
	ld e,c

	and a
	sbc hl,de			; y0 - y1
	ld (p0y_p1y),hl



	pop hl
	ld e,(hl)		; e = x2
	inc hl
	ld a,(hl)		; a = y2

	ld h,0
	ld d,h
	ld l,b			; l = x1
	ex de,hl

	and a
	sbc hl,de		; x2 - x1
	ld (p2x_p1x),hl

	ld h,0
	ld l,a
	ld d,h
	ld e,c
	and a
	sbc hl,de		; y2 - y1
	ld (p2y_p1y),hl

		; now do the 4 multiplies.
	
	ld a,(bezier_t)
	ld hl,TSQRD
	ld d,0
	ld e,a
	add hl,de
	ld e,(hl)		; de = t^t*256
	ld bc,(p2x_p1x)
	push de
	call signed_multiply_16x16			; de * bc = dehl
	
	ld l,h
	ld h,e		; divide by 256
	ld (bezier_tmp_0),hl
	
	pop de
	ld bc,(p2y_p1y)
	call signed_multiply_16x16
	
	ld l,h
	ld h,e
	ld (bezier_tmp_1),hl

; ---- ok so far ----


	ld a,(bezier_t)
	ld hl,OMT
	ld d,0
	ld e,a
	add hl,de
	ld e,(hl)		; de = 256*(1-t)^2
	ld bc,(p0x_p1x)

	push de
	call signed_multiply_16x16

	ld l,h
	ld h,e
	ld (bezier_tmp_2),hl

	pop de
	ld bc,(p0y_p1y)
	call signed_multiply_16x16
	ld l,h
	ld h,e
	ld (bezier_tmp_3),hl
	
	; finally calculate the result.
	
	ld bc,(bezier_y1)
	
	ld h,0
	ld l,b		; hl = p1x
	ld de,(bezier_tmp_0)
	add hl,de
	ld de,(bezier_tmp_2)
	add hl,de

	ld b,l					; b = result(x)
	
	ld h,0
	ld l,c			; hl = p1y

	ld de,(bezier_tmp_1)
	add hl,de

	ld de,(bezier_tmp_3)
	add hl,de
	ld h,b
	ret

;mul_8x8:	; does d * e, result in hl
		; modified from zak's book (approx page 128)
		; loop unrolled so that bc = unchanged
	
;	ld h,d
;	xor a
;	ld l,a			; l = 0
;	ld d,a			; d = 0
;	add hl,hl
;	jr nc,mul_8x8_0
;	add hl,de
;mul_8x8_0:
;	add hl,hl
;	jr nc,mul_8x8_1
;	add hl,de
;mul_8x8_1:
;	add hl,hl
;	jr nc,mul_8x8_2
;	add hl,de
;mul_8x8_2:
;	add hl,hl
;	jr nc,mul_8x8_3
;	add hl,de
;mul_8x8_3:
;	add hl,hl
;	jr nc,mul_8x8_4
;	add hl,de
;mul_8x8_4:
;	add hl,hl
;	jr nc,mul_8x8_5
;	add hl,de
;mul_8x8_5:
;	add hl,hl
;	jr nc,mul_8x8_6
;	add hl,de
;mul_8x8_6:
;	add hl,hl
;	jr nc,mul_8x8_7
;	add hl,de
;mul_8x8_7:
;	ret



; signed 16 bit multiply from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Multiplication

; call with bc, de = 16 bit signed numbers to multiply
; returns   de:hl = 32 bit signed product
; corrupts  a

; de:hl = bc*de

signed_multiply_16x16:
  xor a
  ld h,a
  ld l,a

  bit 7,d
  jr z,muldpos
  sbc hl,bc
muldpos:

  or b
  jp p,mulbpos
  sbc hl,de
mulbpos:

  ld a,16
mulloop:
  add hl,hl
  rl e
  rl d
  jr nc,mul0bit
  add hl,bc
  jr nc,mul0bit
  inc de
mul0bit:
  dec a
  jr nz,mulloop
  ret
	

;exp1x:	defw 0
;exp1y:	defw 0
;exp2x:	defw 0 
;exp2y:	defw 0
;bezier_temp:	defb 0

	; -----------------------------------------------------
	; -----------------------------------------------------
			; boxy (proportional) font routines 
	; -----------------------------------------------------
	; -----------------------------------------------------

font_widths:				; in pixels.
	defb 4,7,9,7,10,9,4,5
	defb 5,6,8,5,6,4,6,7
	defb 4,7,7,7,7,7,7,7
	defb 7,4,4,6,6,6,8,8
	defb 7,7,7,7,7,7,7,7
	defb 4,7,7,7,9,8,7,7
	defb 8,7,7,8,7,7,9,7
	defb 8,7,5,6,5,8,6,5
	defb 7,7,6,7,7,6,7,7
	defb 5,6,7,5,9,7,7,7
	defb 7,7,7,6,7,7,9,7
	defb 7,7,5,4,5,9

font_glyph_height:	equ 9		; all glyphs are the same height in pixels.

font_data:
	; boxy font, 9x8 pixels wide.
defb 240,144,144,144,240,144,240,240,0
defb 254,146,146,254,254,0,0,0,0
defb 127,201,128,201,128,201,127,119,0
defb 254,130,174,130,234,130,254,254,0
defb 255,141,171,128,245,44,63,59,0
defb 254,130,147,198,145,132,255,255,0
defb 240,144,144,240,240,0,0,0,0
defb 120,200,152,152,152,200,248,120,0
defb 240,152,200,200,200,152,248,240,0
defb 120,204,132,204,180,252,204,0,0
defb 60,36,231,129,231,231,60,60,0
defb 0,0,120,72,200,152,248,240,0
defb 0,0,252,132,252,252,0,0,0
defb 0,0,0,240,144,144,240,240,0
defb 60,36,100,204,156,152,240,240,0
defb 254,130,146,146,146,130,254,254,0
defb 240,144,144,144,144,144,240,240,0
defb 254,130,242,130,158,130,254,254,0
defb 254,130,242,66,242,130,254,254,0
defb 254,146,146,130,242,242,30,30,0
defb 254,130,158,130,242,130,254,254,0
defb 254,130,158,130,146,130,254,254,0
defb 254,130,242,242,18,18,30,30,0
defb 254,130,146,130,146,130,254,254,0
defb 254,130,146,130,242,130,254,254,0
defb 240,144,144,240,144,144,240,240,0
defb 240,144,144,240,144,208,240,112,0
defb 60,100,204,152,204,228,124,60,0
defb 0,252,132,252,132,252,252,0,0
defb 240,152,204,100,204,156,248,240,0
defb 255,129,153,243,255,38,60,60,0
defb 255,129,153,145,159,129,255,255,0
defb 254,130,146,130,146,146,254,238,0
defb 254,130,146,134,146,130,254,254,0
defb 254,130,158,156,158,130,254,254,0
defb 252,134,146,146,146,134,254,252,0
defb 254,130,158,132,158,130,254,254,0
defb 254,130,158,134,156,156,240,240,0
defb 254,130,158,158,146,130,254,254,0
defb 254,146,146,130,146,146,254,238,0
defb 240,144,144,144,144,144,240,240,0
defb 30,18,18,242,146,130,254,254,0
defb 254,146,146,134,146,146,254,254,0
defb 240,144,144,144,158,130,254,254,0
defb 247,156,136,128,148,156,255,247,0
defb 255,153,137,129,145,153,255,239,0
defb 254,130,146,146,146,130,254,254,0
defb 254,130,146,130,158,158,240,240,0
defb 254,130,146,146,147,129,255,255,0
defb 254,130,146,134,146,146,254,238,0
defb 254,130,158,130,242,130,254,254,0
defb 255,129,231,231,36,36,60,60,0
defb 254,146,146,146,146,130,254,254,0
defb 254,146,146,146,198,238,124,56,0
defb 247,156,148,128,136,156,255,247,0
defb 254,146,146,198,146,146,254,238,0
defb 255,153,153,195,231,102,60,60,0
defb 254,130,242,130,158,130,254,254,0
defb 248,136,152,152,152,136,248,248,0
defb 240,144,152,204,228,100,60,60,0
defb 248,136,200,200,200,136,248,248,0
defb 60,102,195,153,255,231,0,0,0
defb 0,0,0,0,252,132,252,252,0
defb 240,144,152,200,248,120,0,0,0
defb 0,254,130,242,146,130,254,254,0
defb 240,158,130,146,146,130,254,254,0
defb 0,252,132,156,156,132,252,252,0
defb 30,242,130,146,146,130,254,254,0
defb 0,254,130,146,158,130,254,254,0
defb 124,68,204,132,204,204,120,120,0
defb 0,254,130,146,130,242,194,126,126
defb 240,158,130,146,146,146,254,254,0
defb 120,72,248,136,200,200,120,120,0
defb 60,36,124,68,100,228,132,252,252
defb 240,158,146,134,146,146,254,254,0
defb 248,136,200,200,72,72,120,120,0
defb 0,255,128,148,148,148,255,255,0
defb 0,254,130,146,146,146,254,254,0
defb 0,254,130,146,146,130,254,254,0
defb 0,254,130,146,146,130,158,254,240
defb 0,254,130,146,146,130,242,254,30
defb 0,254,130,158,158,144,240,240,0
defb 0,254,130,142,226,130,254,254,0
defb 120,204,132,204,204,68,124,124,0
defb 0,254,146,146,146,130,254,254,0
defb 0,254,146,146,198,238,124,56,0
defb 0,255,148,148,148,128,255,255,0
defb 0,254,146,198,146,146,254,254,0
defb 0,254,146,146,130,242,194,126,126
defb 0,254,130,226,142,130,254,254,0
defb 120,200,152,136,152,200,248,120,0
defb 240,144,144,144,144,144,240,240,0
defb 240,152,200,136,200,152,248,240,0
defb 127,196,145,255,255,0,0,0,0

font_char_width:
	; a = character value, 
	; returns a = character width

	sub 33
	ld hl,font_widths
	add a,l
	ld l,a
	ld a,h
	adc a,a
	ld h,a
	ld a,(hl)
	ret
	
font_string_width:
	; hl = address of string
	; b = length of string
	; returns the length of the string in pixels in c
	
fsw0:
	push hl
	ld a,(hl)
	call font_char_width
	add a,c
	ld c,a
	pop hl
	inc hl
	djnz fsw0
	ret

font_draw_char:
		;	a = char code (0..127)
		;	d = x coord (0..255)
		;	e = y coord (0..255)
		
	sub 33			; first 33 characters are not used (but they could be...!!)
	ret c				; return if character < 33
	cp 128-33
	ret nc				; return if character > 127

	ld b,0
	ld c,a
	ld h,b
	ld l,c
	add hl,hl
	add hl,hl
	add hl,hl
	add hl,bc			; hl = char code * 9
	ld bc,font_data
	add hl,bc

	push hl				; hl = font data address

	ld a,d
	neg
	and 7
	ld b,a				; store rotation info

	ld a,d
	ld d,0
	ld hl,row_table
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)	; de = screen row address.
	rrca		;4		; replace slr a * 3, for slight optimisation!
	rrca		;4		; 5 bytes, 19 t states.
	rrca		;4
	and 0x1F	;7
	ld h,0
	ld l,a
	add hl,de	;hl = screen address to draw pixel at.

	pop de		; de = font data address

	ld a,b
	and a
	jp z, fdc_norotate

	
	ld c,9		; b = character height
fdc_loop0:
	push bc

	ld a,(de)	; get byte to rotate
	push de		; store data address
	
	ld e,a
	ld d,0

	ex de,hl
fdc_loop1:
	add hl,hl
	djnz fdc_loop1
	ex de,hl

	ld a,d
	or (hl)
	ld (hl),a
	inc l
	ld a,e
	or (hl)
	ld (hl),a
	dec l
	call IncRow
	
	pop de		; retrieve data address
	inc de

	pop bc
	dec c
	jp nz,fdc_loop0
	ret
	
	; no rotate = special case (really small loop!)

fdc_norotate:
	ld b,9
fdc_norotate_loop:	
	ld a,(de)
	or (hl)
	ld (hl),a
	call IncRow
	inc de
	djnz fdc_norotate_loop
	ret


font_draw_string:
	; draws a proportionally spaced string.
	
	; hl = string address
	; b = string length
	;	d = x coord (0..255)
	;	e = y coord (0..255)
	
fds0:
	push bc
	push hl
	push de
	
	ld a,(hl)
	push af
	call font_draw_char
	pop af
	call font_char_width
	pop de
	add a,d
	ld d,a
	pop hl
	inc hl
	pop bc
	djnz fds0
	ret

	; ------------------------------------------------------------
	;
	;	Experimental map drawing code.
	;
	;	16x16 map characters, have to be able to scroll 2 pixels
	;
	;	at a time in all directions.
	;
	;		idea.... Each character can be repeated horizontally,
	; storing each possible position pre-rotated is possibly prohibitive so...
	;
	;		A	   B     C
	;	+------+------+------+
	;	|rrrrrr|######|######|
	;	+------+------+------+
	;
	;	Each character is stored as a group of 3 (or more) characters,
	;	so that A is initially blank, and used to rotate the 
	;	graphics into
	;
	;	All three characters are rotated internally, then used to just
	;	draw them all as pre-rotated characters.
	;
	;	Each character is stored as a two byte offset from the start
	;	of the character set data, so I can easily swap character sets
	;	if required.
	;	
	;	16 pixels per character, gives 16 character blocks per screen row
	;	and 12 character blocks per column. Two bytes per character gives
	;	a total of 16 x 12 x 2 bytes per screen = 384 bytes per screen.
	;
	;	going to do a 2 pixel vertical scroll so need 4 separate 
	;	character drawing routines.
	;
	;	ld a,(hl)		; 7		- old way of doing things.
	;	ld (de),a		; 7
	;	inc hl			; 6
	;	inc e			; 4
	;	ld a,(hl)		; 7
	;	ld (de),a		; 7
	;	inc hl			; 6
	;	dec e			; 4
					; 48
	
	;	ldi				; 16	; slightly better optimised
	;	ldi				; 16	; (without stack abuse!!)
	;	dec l			; 4
	;	dec l			; 4
	;					; 40
	; ------------------------------------------------------------

num_map_rows:	equ 11				; max 11

map_width:			equ 15				; max width = 15
;map_width_bytes:	equ map_width* 2
;map_height:			equ 12
map_screen_address:	defw 0
map_address:		defw 0

map_y:	defw 192		;	current map_y coordinate. 

map_offset:		defb 0	; offset = 0,2,4,6,8,10,12,14

DrawMap:
	ld hl, map_data
	ld (map_address),hl

		; calculate screen address, based on map_offset value.
	ld a,(map_offset)
	ld e,a
	and 6			;000, 010 , 100, 110
;	or 0x40
	or 0xe0			; screen buffer is at 0xe000
	ld d,a			; d = 0x40, 0x42, 0x44, 0x46
	ld a,e
	add a,a
	add a,a
	and 32
	add a,1			; offset from left of screen
	ld e,a			; e = 0 or 32.
	ld (map_screen_address),de

	ld a,(map_offset)
	and 6
	jp z, DrawMap0
	cp 2
	jp z, DrawMap2
	cp 4
	jp z, DrawMap4
	jp DrawMap6
	
DrawMap0:

;	ld hl, map_data
;	ld (map_address),hl

;	ld de,0x4001				; addr 16384, start of screen.
;	ld (map_screen_address),de

	
;	ld a,64
;	ld (map_tmp),a
	
	ld a, num_map_rows
map_loop_rept:
	push af
	push de

	ld bc, 32*map_width

map_loop_0:

;	ld a,(map_tmp)
;	dec a
;	ld (map_tmp),a


	ld hl,(map_address)
	ld e,(hl)
	inc hl
	ld d,(hl)				; de = offset into character set.
	inc hl
	ld (map_address),hl
	ld hl,map_chrset_address
	add hl,de
	
	ld de,(map_screen_address)

	ldi				; row 1-2		16
	ldi				; 			16
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.
	dec e			;			4
	dec e
	inc d			;					; = 36
	ldi
	ldi
	dec e
	dec e
	inc d
	ldi				;3-4
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi				; 5-6
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi				; 7-8
	ldi
	dec e
	dec e
	inc d
	
	ldi
	ldi
;	dec de
	dec e
	dec e
	inc d

;	ld a,(map_tmp)
;	and a
;	jr nz,map1234

;	inc h
;	ld a,h
;	and 7
;	ret nz
;	ld a,l
;	add a,32
;	ld l,a
;	ret c
;	ld a,h
;	sub 8
;	ld h,a
;	ret

	ld a,e
	add a,32
	ld e,a
	jp c,map0
	ld a,d
	sub 8
	ld d,a

;	ld a,0xff
;	ld (de),a
;halt
;map1234:

map0:
	ldi			; 9-10
	ldi
;	dec de		; NOTE : HAS TO BE 'DEC DE' AND NOT JUST 'DEC E' TO HANDLE OVERFLOW AT RHS EDGE OF SCREEN 1/3rd. (WHICH IS ANNOYING!!)
	dec e
	dec e
	inc d
	ldi
	ldi
;	dec de
	dec e
	dec e
	inc d

	ldi			; 11-12
	ldi
;	dec de
	dec e
	dec e
	inc d
	ldi
	ldi
;	dec de
	dec e
	dec e
	inc d

	ldi			; 13-14
	ldi
;	dec de
	dec e
	dec e
	inc d
	ldi
	ldi
;	dec de
	dec e
	dec e
	inc d

	ldi			; 15-16
	ldi
;	dec de
	dec e
	dec e
	inc d
	ldi
	ldi
	jp pe, map_loop_0
;halt
	pop de
	
	ld a,e
	add a,64
	ld e,a
	jp nc,map1
;halt
	ld a,d
	add a,8
;	sub 8
	ld d,a
map1:
	
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.

;	ld a,0xAA
;	ld (de),a
;halt
	pop af
	dec a
	and a
	jp nz, map_loop_rept
	ret
	
	
	
;	ld hl,(map_address)
;	ld de,(map_width_bytes)
;	add hl,de
;	ld (map_address),hl
;	pop bc
;	djnz	map_loop_0
;	ld b,16
;	dec c
;	jp nz, map_loop_0

;	ld hl,16384			// screen address.
;	ld de,map_data

;	ld b,map_height
;loop:
;	ld c,map_width
;	push bc

;	push de
;	push hl

;	ld a,(de)
;	ld d,0
;	ld e,a
;	ld hl,map_gfx_addr
;	add hl,de
;	ex de,hl
	
;	pop hl

		; unroll loop, dump 8 bytes in a row.
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24
;	ld a,(de)	7
;;	inc de		6
;	ld (hl),a	7
;	inc h		4			= 24

;	pop de			; code to move map address down one row
;	push hl
;	ld hl, map_width
;	add hl,de
;	ex de,hl
;	pop hl



	; ---------------- draw map 2 pixels down screen -----------------


DrawMap2:

;	ld hl, map_data
;	ld (map_address),hl

;	ld de,0x4201				; addr 16384, start of screen.
;	ld (map_screen_address),de

;	ld a,0xAA
;	ld (de),a

	ld a, num_map_rows
map_loop_rept2:
	push af
	push de

	ld bc, 32*map_width

map_loop_2:

	ld hl,(map_address)
	ld e,(hl)
	inc hl
	ld d,(hl)				; de = offset into character set.
	inc hl
	ld (map_address),hl
	ld hl,map_chrset_address
	add hl,de
	
	ld de,(map_screen_address)

	ldi				; row 1-2		16
	ldi				; 			16
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.
	dec e			;			4
	dec e
	inc d			;					; = 36
	ldi
	ldi
	dec e
	dec e
	inc d
	ldi				;3-4
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi				; 5-6
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s2
	ld a,d
	sub 8
	ld d,a
map_s2:

	ldi				; 7-8
	ldi
	dec e
	dec e
	inc d
	
	ldi
	ldi
	dec e
	dec e
	inc d

;	ld a,0xff
;	ld (de),a
;halt
;map1234:

	ldi			; 9-10
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 11-12
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 13-14
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s22
	ld a,d
	sub 8
	ld d,a
map_s22:

	ldi			; 15-16
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	jp pe, map_loop_2
;halt
	pop de
	
	ld a,e
	add a,64
	ld e,a
	jp nc,map_t2
;halt
	ld a,d
	add a,8
	ld d,a
map_t2:
	
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.

;	ld a,0xAA
;	ld (de),a
;halt
	pop af
	dec a
	and a
	jp nz, map_loop_rept2
	ret


	; ---------------- draw map 4 pixels down screen -----------------


DrawMap4:

;	ld hl, map_data
;	ld (map_address),hl

;	ld de,0x4401				; addr 16384, start of screen.
;	ld (map_screen_address),de

;	ld a,0xAA
;	ld (de),a
;halt
	ld a, num_map_rows
map_loop_rept4:
	push af
	push de

	ld bc, 32*map_width

map_loop_4:

	ld hl,(map_address)
	ld e,(hl)
	inc hl
	ld d,(hl)				; de = offset into character set.
	inc hl
	ld (map_address),hl
	ld hl,map_chrset_address
	add hl,de
	
	ld de,(map_screen_address)

	ldi				; row 1-2		16
	ldi				; 			16
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.
	dec e			;			4
	dec e
	inc d			;					; = 36
	ldi
	ldi
	dec e
	dec e
	inc d
	ldi				;3-4
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s4
	ld a,d
	sub 8
	ld d,a
map_s4:

	ldi				; 5-6
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d


	ldi				; 7-8
	ldi
	dec e
	dec e
	inc d
	
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 9-10
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 11-12
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s44
	ld a,d
	sub 8
	ld d,a
map_s44:


	ldi			; 13-14
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d


	ldi			; 15-16
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	jp pe, map_loop_4
	pop de
	
	ld a,e
	add a,64
	ld e,a
	jp nc,map_t4
	ld a,d
	add a,8
	ld d,a
map_t4:
	
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.

	pop af
	dec a
	and a
	jp nz, map_loop_rept4
	ret





	; ---------------- draw map 6 pixels down screen -----------------


DrawMap6:

;	ld hl, map_data
;	ld (map_address),hl

;	ld de,0x4601				; addr 16384, start of screen.
;	ld (map_screen_address),de

;	ld a,0xAA
;	ld (de),a
;halt
	ld a, num_map_rows
map_loop_rept6:
	push af
	push de

	ld bc, 32*map_width

map_loop_6:

	ld hl,(map_address)
	ld e,(hl)
	inc hl
	ld d,(hl)				; de = offset into character set.
	inc hl
	ld (map_address),hl
	ld hl,map_chrset_address
	add hl,de
	
	ld de,(map_screen_address)

	ldi				; row 1-2		16
	ldi				; 			16
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.
	dec e			;			4
	dec e
	inc d			;					; = 36
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s6
	ld a,d
	sub 8
	ld d,a
map_s6:

	ldi				;3-4
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi				; 5-6
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d


	ldi				; 7-8
	ldi
	dec e
	dec e
	inc d
	
	ldi
	ldi
	dec e
	dec e
	inc d

;	ld a,0xff
;	ld (de),a
;halt
	ldi			; 9-10
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ld a,e
	add a,32
	ld e,a
	jp c,map_s66
	ld a,d
	sub 8
	ld d,a
map_s66:


	ldi			; 11-12
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 13-14
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	dec e
	dec e
	inc d

	ldi			; 15-16
	ldi
	dec e
	dec e
	inc d
	ldi
	ldi
	jp pe, map_loop_6
	pop de
	
	ld a,e
	add a,64
	ld e,a
	jp nc,map_t6
;halt
	ld a,d
	add a,8
	ld d,a
map_t6:
	
	ld (map_screen_address),de			; store for next character along before adjusting for next character row.

;	ld a,0xAA
;	ld (de),a
;halt
	pop af
	dec a
	and a
	jp nz, map_loop_rept6
	ret

Times30Table:
	defw	0,30,60,90,120,150,180,210,240,270,300,330

DrawMapAttrRow:
	; complicated as there are three data addresses required
	; the attribute map, the map data and the colour data.

	; a = row (0-11)
	; row * 64

	add a,a		; a = row * 2
	ld h,0
	ld l,a
	ld de,Times30Table
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)			; de = row * 30
	ld hl,map_data
	add hl,de

	push hl
	; need to load de with attr row buffer address.
	add a,a	;x4
	add a,a	;x8
	add a,a ;x16
	ld h,0
	ld l,a
;	add hl,hl	; x4
;	add hl,hl	; x8
;	add hl,hl	; x16
	add hl,hl	; x32
	add hl,hl	; x64
	ld de, ATTR_BUFFER
	add hl,de
	ex de,hl
	inc de			; start at (1,0), not (0,0)

	pop hl

	; hl = map data address
	; de = attr buffer address

	ld b,15
DMAR0:
	push bc
	ld c,(hl)		; get map character
	inc hl
	ld b,(hl)
	inc hl
	push hl
	
		; bc = character map offset, which = character code * 32.
		; need attribute offset = character code * 4	(as 4 colour bytes per character)
		;     32 16 8 4 2 1
		; so right shift de 3 times.
	
	ld a,b
	or c
	jr nz,DMAR1
	; skip blank squares.??
	inc e
	inc e
	jr DMAR2
	

DMAR1:
	srl b
	rr c
	srl b
	rr c
	srl b
	rr c
	ld hl,map_character_attributes
	add hl,bc

	ld bc,4
	ldi				; de = attr map address
	ldi				; hl = char attr address.
	
	ld a,e			; add 30 to de (fastest way ???)
	add a,30
	ld e,a
	ld a,d		; dont think I need these 3 lines as attributes
	adc a,0		; are drawn in 2 blocks of 32 that don't cross a??
	ld d,a		; 256 byte aligned address ??

	ldi				; fill in 2nd row
	ldi
	
	ld a,e
	sub 32
	ld e,a

DMAR2:
	pop hl
	pop bc
	djnz DMAR0
	ret

DrawMapAttr:
	; draws the attributes for the entire screen ??

	ld b,11
DrawMapAttr0:
	push bc
	ld a,11
	sub b
	call DrawMapAttrRow
	pop bc
	djnz DrawMapAttr0
	ret

map_data:

		; each screen is 15 blocks wide, 11 high = 165 bytes.
		; each word is an offset into the character set for 
		; a single block.

		; data = character code * 32 (so its a direct offset into the character data)
	
	defw 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	defw 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x60,0x00,0x80,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
	defw 0x40,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40
;	map_last_row:
	defw 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40

;	defw 0x40,0x60,0x60,0x80,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x40
;	defw 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
;map_data_end:

map_scroll_down:
	ld hl, map_data
	ld de, 0+(map_width*2*num_map_rows)-1
	add hl,de
	push hl
	ld de, map_width*2		;map_width*2
	and a
	sbc hl,de
	pop de
	ld bc,map_width*2*(num_map_rows-1)
	lddr
	ret

map_scroll_up:
	ld de, map_data
	ld hl, map_width*2
	add hl,de

	ld bc,map_width*2*(num_map_rows-1)
	ldir
	ret

map_uncompress_row:
	; de = map row [0..11]
	; hl = map_character_map row [0..100]

	push hl
	
	ld h,d
	ld l,e

	add hl,hl
	add hl,hl
	add hl,hl
	add hl,hl
	add hl,hl		; * 32
	and a
	sbc hl,de
	sbc hl,de		; * 30
	ld de,map_data
	add hl,de		; hl = map row address to write to.

	pop de
	push hl	

	ld h,d
	ld l,e
	add hl,hl
	add hl,hl
	add hl,hl
	add hl,hl
	and a
	sbc hl,de		; row * 16 - row = fast multiply by 15 :-)
	ld de,map_character_map
	add hl,de		; hl = character map address.
	ex de,hl

	pop hl

		; hl = map row address, de = character map address
	
;	ld de,map_character_map
	ld b,15
_uncompress_row_0:
	ld a,(de)
	inc de
	push de
	push hl
	ld h,0
	ld l,a
	add hl,hl
	add hl,hl
	add hl,hl
	add hl,hl
	add hl,hl		; * 32.
	ex de,hl
	pop hl
	ld (hl),e
	inc hl
	ld (hl),d
	inc hl
	pop de
	djnz _uncompress_row_0
	ret

MoveAttrMapUp:
;	ld DE, SCREEN_BUFFER + 6144+32+32
;	ld hl, SCREEN_BUFFER + 6144+32+32+32
;	ld bc, 19*32
;	ldir
;	ret
	ld de, ATTR_BUFFER + 64
	ld hl, ATTR_BUFFER + 96
	ld bc, 21 * 32
	ldir
	ret

MoveAttrMapDown:
;jr MoveAttrMapDown
	ld hl, ATTR_BUFFER + (32*21)
	ld de, ATTR_BUFFER + (32*22)
	ld bc, 21*32
	lddr
	ret

MoveMapDown:
	; map y moves down, which has the effect of moving the on screen
	; map *up*. 
	
	
	;	working out how to sync the attribute update to the map update
	; is harder than you think.
	
	; to move the map 'up', the map_offset value has to decrease by 2
	; from 14 to 0 each loop round.
	;
	; the map y coordinate goes from 0 to 14 - so you have to xor the
	; y coordinate to get the offset value.
	


;womble
	ld a,(map_y)		; low byte
	and 14
	cp 14
	jr nz,MMD00
	call map_scroll_up

	ld hl,(map_y)		// divide by 16
	srl h
	rr l
	srl h
	rr l
	srl h
	rr l
	srl h
	rr l

	ld de,10
	call map_uncompress_row
	
MMD00:
	ld hl,(map_y)
	inc hl
	inc hl
	ld (map_y),hl

	ld a,l
	cpl
	and 14
	ld (map_offset),a


	ret
	
;	push hl
;	ld a,l
;	cpl			;xor 14
;	and 14
;	ld (map_offset),a
;	cp 14
;	call z, map_scroll_up

;	ld a,(map_offset)
;	and 6
;	cp 6
;	call z,MoveAttrMapUp

;	ld a,(map_offset)
;	and 14
;	cp 6
;	call z, MoveAttrMapUp
	
	
;	pop hl

;	ld hl,(map_y)		// divide by 16
;	srl h
;	rr l
;	srl h
;	rr l
;	srl h
;	rr l
;	srl h
;	rr l

;	ld de,10
;	call map_uncompress_row

;	ld a,10
;	call DrawMapAttrRow

;	push hl
;	ld a,l
;	and a
;	jr nz,mmd55
;	ld a,10
;	call DrawMapAttrRow
;	pop hl
;mmd55:
;	ret

;	cpl
;	and 6
;	call z, MoveAttrMapUp
;	pop hl
	
;	ld a,l
;	xor 14
;	and 14
;	ld (map_offset),a
;	cp 14
;	ret nz				; 

;	call map_scroll_up
	
;	ld hl,(map_y)		// divide by 16
;	srl h
;	rr l
;	srl h
;	rr l
;	srl h
;	rr l
;	srl h
;	rr l
;	ld de,10			; why add 10 ????
;	add hl,de

;	ld de,10
	
;map_uncompress_row:
	; de = map row [0..10]
	; hl = map_character_map row [0..200]

;	call map_uncompress_row
	
;	call map_scroll_down

;	ld a,10
;	call DrawMapAttrRow


	ret

MoveMapUp:
	; moves map up 2 pixels and updates the map data.
	; map_y moves up, which has the effect of moving the on screen
	; map *down*. 

	ld hl,(map_y)	
	ld a,l
	and 0xF0
	dec hl
	dec hl
	ld (map_y),hl

	push hl
	ld a,l
	cpl
	and 6
;	cp 6
	call z, MoveAttrMapDown
	pop hl
	
	ld a,l
	xor 14
	and 14
	ld (map_offset),a
;	cp 14
	ret nz				; 

	call map_scroll_down
	
	ld hl,(map_y)		// divide by 16
	srl h
	rr l
	srl h
	rr l
	srl h
	rr l
	srl h
	rr l
	ld de,10
	add hl,de

	ld de,0
	

;map_uncompress_row:
	; de = map row [0..10]
	; hl = map_character_map row [0..100]

	call map_uncompress_row

;	call map_scroll_down

	ld a, 0
	call DrawMapAttrRow

	ret


	

map_character_map:		; (100 rows, 15 bytes per row = 1500 bytes.)

		; each row should be run length encoded to save space.
		; maybe even just have 16 block types, so each byte holds 2
		; blocks, then run length encode it, and possibly store
		; levels that are not being used in a sort of compressed
		; format and unpacked only when required ???

	defb 1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1
	defb 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0	; top row blank for testing. 
	defb 1,0,3,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,3,0, 5,5,5,0,0, 0,0,0,0,1
	defb 1,0,0,0,3, 4,4,4,0,0, 0,0,0,0,1
	defb 1,2,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,2,0,0, 0,0,0,0,1
	defb 1,0,0,2,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1		;2
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,2,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,2, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,2,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,1,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,1,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,1,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,2,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,1,0, 0,0,0,0,0, 0,0,0,0,1		; 4
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 6
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 8
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 10
	defb 1,1,0,0,0, 0,0,0,0,0, 0,0,0,1,1
	defb 1,0,1,0,0, 0,0,0,0,0, 0,0,1,0,1
	defb 1,0,0,1,0, 0,0,3,3,0, 0,1,0,0,1
	defb 1,0,2,0,1, 0,0,0,3,0, 1,0,0,0,1
	defb 1,0,2,0,0, 1,0,0,0,1, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,3,3,3,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,3,3,3,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,3,3,3,0, 0,0,0,0,1



	defb 1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1
	defb 1,1,1,1,1, 0,0,0,0,0, 1,1,1,1,1
	defb 1,0,3,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,3,0, 5,5,5,0,0, 0,0,0,0,1
	defb 1,0,0,0,3, 4,4,4,0,0, 0,0,5,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,5,5,0,1
	defb 1,0,2,0,0, 0,0,2,0,0, 0,5,5,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,5,5,0,1
	defb 1,0,2,2,0, 0,0,0,0,0, 0,5,5,0,1
	defb 1,0,2,2,0, 0,0,0,0,0, 0,0,5,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1		;2
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,5,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,5,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,5,0,0,1
	defb 1,0,0,5,0, 0,0,0,0,0, 0,5,0,0,1
	defb 1,0,0,5,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,5,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,6,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 6,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 6,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 6,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1		; 4
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,7,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,7,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,7,0, 0,0,8,8,0, 0,0,0,0,1
	defb 1,0,0,7,0, 0,0,8,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 6
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 8
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,3,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 3,0,0,3,0, 0,0,0,0,1
	defb 1,0,2,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,2,0,0, 3,1,1,1,1, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1
	defb 1,0,0,0,0, 3,0,0,0,0, 0,0,0,0,1

	defb 1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,1	; 10
	defb 1,1,0,0,0, 0,0,0,0,0, 0,0,0,1,1
	defb 1,0,1,0,0, 0,0,0,0,0, 0,0,1,0,1
	defb 1,0,0,1,0, 0,0,3,3,0, 0,1,0,0,1
	defb 1,0,2,0,1, 0,0,0,3,0, 1,0,0,0,1
	defb 1,0,2,0,0, 1,0,0,0,1, 0,0,0,0,1
	defb 1,0,2,0,0, 0,1,1,1,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,3,3,3,0, 0,0,0,0,1
	defb 1,0,0,0,0, 0,3,3,3,0, 0,0,0,0,1
	defb 1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1








	
map_chrset_address:
	defw 0x0000				; first character is just a blank 
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000
	defw 0x0000

	defw 0xFFFF			;	11111111 11111111
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defw 0xFFFF			;	11111111 11111111

	defb 0xF0,0x0F		;	11110000 00001111
	defb 0x80,0x01		;	10000000 00000001
	defb 0x80,0x01		;	10000000 00000001
	defb 0x8F,0xF1		;	10001111 11110001
	defb 0x88,0x11		;	10001000 00010001
	defb 0x88,0x11		;	10001000 00010001
	defb 0x88,0x11		;	10001000 00010001
	defb 0x88,0x11		;	10001000 00010001
	defb 0,0
	defb 0,0
	defb 0,0
	defb 0,0
	defb 0,0
	defb 0,0
	defb 0,0
	defb 0,0
;	defb 0x88,0x11		;	10001000 00010001
;	defb 0x88,0x11		;	10001000 00010001
;	defb 0x88,0x11		;	10001000 00010001
;	defb 0x88,0x11		;	10001000 00010001
;	defb 0x8F,0xF1		;	10001111 11110001
;	defb 0x80,0x01		;	10000000 00000001
;	defb 0x80,0x01		;	10000000 00000001
;	defb 0xFE,0x7F		;	11111110 01111111


	defw 0xFFFF			;	11111111 11111111
	defw 0x0800			;	00001000 00000000
	defw 0x0800			;	00001000 00000000
	defw 0x0800			;	00001000 00000000
	defw 0xffff			;	11111111 11111111
	defw 0x0080			;	00000000 00001000
	defw 0x0080			;	00000000 00001000
	defw 0x0080			;	00000000 00001000
	defw 0xffff			;	11111111 11111111
	defw 0x0800			;	00001000 00000000
	defw 0x0800			;	00001000 00000000
	defw 0x0800			;	00001000 00000000
	defw 0xFFFF			;	11111111 11111111
	defw 0x0008			;	00000000 00001000
	defw 0x0008			;	00000000 00001000
	defw 0x0008			;	00000000 00001000

	defb 0xFF,0xFF			; 11111111 11111111
	defb 0x80,0x01			; 10000000 00000001
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0xBF,0xFD			; 10111111 11111101
	defb 0x80,0x01			; 10000000 00000001
	defb 0xFF,0xFF			; 11111111 11111111

	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111


	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0xF0,0xF0			; 11110000 11110000
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00001111 00001111
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000
	defb 0x0F,0x0F			; 00000000 00000000

map_character_attributes:
	; 4 bytes per character (for static, non scrolling screens).

;ink_black:		equ 0
;ink_blue:		equ 1
;ink_red:		equ 2
;ink_magenta:	equ 3
;ink_green:		equ 4
;ink_cyan:		equ 5
;ink_yellow:		equ 6
;ink_white:		equ 7

;paper_black:	equ 0
;paper_blue:		equ 8	;(1<<3)
;paper_red:		equ (2<<3)
;paper_magenta:	equ (3<<3)
;paper_green:	equ (4<<3)
;paper_cyan:		equ (5<<3)
;paper_yellow:	equ (6<<3)
;paper_white:	equ 56	;(7<<3)

	defb ink_white,ink_white,ink_white,ink_white	;paper_black + ink_black

	defb ink_blue + bright, ink_blue, ink_blue + bright, ink_blue

	defb ink_red, ink_red, ink_red, ink_red

	defb ink_yellow, ink_yellow, ink_yellow, ink_yellow

	defb ink_magenta, ink_magenta, ink_magenta, ink_magenta


TestString:	defs "Hello World"

	; --------------------------------------------------------------
	;
	;	---- Collision detection stuff ----
	;
	; ------------------------------------------------------------

PointInSlope:
	; call with hl and de with the slope coordinates and bc the point to test
	;	h = x0, l = y0, d = x1, e = y1, b = px, c = py
	;
	;	returns a = 0, no collision, else a = 255
	;
	;	NOTE: coordinates *MUST* be so that x0 < x1
	;
	;
	;

		; if ((px < x0) && (px < x1))	return false

	ld a,b
	cp h
	jr nc, PIS0
	cp d
	jp c, point_not_in_slope


PIS0:
		; if ((px > x0) && (px > x1))	return false
	cp h
	jr c, PIS1
	cp d
	jp nc, point_not_in_slope

PIS1:
		; if ((py < y0) && (py < y1))	return false
	ld a,c
	cp l
	jr nc, PIS2
	cp e
	jp c, point_not_in_slope

PIS2:
		; if ((py > y0) && (py > y1))	return false;
	cp l
	jr c, PIS3
	cp e
	jp nc, point_not_in_slope

PIS3:
	push bc
	
	ld a,d			; dx = abs(x1-x0)
	sub h
	jr nc,PIS4
	neg
PIS4:
	ld b,a			; b = dx

	ld a,e			; dy = abs(y1-y0)
	sub l
	jr nc,PIS5
	neg
PIS5:
	ld c,a			; c = dy

	cp b
	jr z, PIS_dx_equals_dy

;	add a,a			; a = dy<<1
;	cp b
	ld a,b		; note : changed this to hopefully prevent overflow error from dy<<1 (just do dx>>1) instead !!
	srl a
	cp c
	jr z, PIS_dx_equals_2_times_dy

	ld a,c
	srl a
	cp b
	jr z, PIS_dx_half_dy

	; assume dx == (dy<<2) at this point.

PIS_dx_equals_4_times_dy:
	; the test for the slope is as follows (using y = mx + c equation):
	;	 py < (px<<2) + y0 - (x0<<2)
	; but this won't work in 8 bits as the values will overflow, 
	; so everything gets divided by 4 :
	;
	;	(py/4) <= px + (y0/4) - x0
	;
	pop bc
	
	ld a,e		; if (y1 < y0)
	sub l		
	jr nc, PIS_F3
	ld a,h
	neg
	ld h,a		; x0 = -x0
	ld a,b
	neg
	ld b,a		; px = -px
PIS_F3:

	ld a,c
	srl a
	srl a
	ld c,a		;	c = (py/4)

	ld a,l
	srl a
	srl a
	add a,b
	sub h	; a = px + (y0>>2) - x0

;lpokok:	jr lpokok
	
	cp c
;	jr z, point_not_in_slope
	jr nc, point_not_in_slope
	jr point_is_in_slope

PIS_dx_half_dy:
	;	(py/2) <= px + (y0/2) - x0
	pop bc

	ld a,e		; if (y1 < y0)
	sub l		
	jr nc, PIS_F4
	ld a,h
	neg
	ld h,a		; x0 = -x0
	ld a,b
	neg
	ld b,a		; px = -px
PIS_F4:

	ld a,c
	srl a
	ld c,a		;	c = (py>>1)

	ld a,l
	srl a
	add a,b
	sub h	; a = px + (y0>>2) - x0

	cp c
	jr nc, point_not_in_slope
	jr point_is_in_slope







PIS_dx_equals_2_times_dy:		; dx == (dy<<1)
	pop bc
	
	ld a,e		; if (y1 < y0)
	sub l		
	jr nc, PIS_F1
	ld a,h
	neg
	ld h,a		; x0 = -x0
	ld a,b
	neg
	ld b,a		; px = -px
PIS_F1:
	
	ld a,h
	srl a
	neg
	add a,l		;

	ld e,a		;  e = y0 - (x0>>1)
	ld a,b
	srl a
	add a,e		; a = (px>>1) + c
	cp c
	jr nc, point_not_in_slope
	jr point_is_in_slope


PIS_dx_equals_dy:
	pop bc
	
	ld a,e		; if (y1 < y0)
	sub l		
	jr nc, PIS_F0
	ld a,h
	neg
	ld h,a		; x0 = -x0
	ld a,b
	neg
	ld b,a		; px = -px
PIS_F0:
	
	ld a,l		; c = y0 - x0
	sub h
	add a,b		; a = px + c
	cp c
	jr nc, point_not_in_slope

point_is_in_slope:
	ld a,255	;xor a
	ret

point_not_in_slope:
	xor a		;ld a,255
	ret

